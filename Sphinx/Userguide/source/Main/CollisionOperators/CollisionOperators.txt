MPCD supports over 20 unique collision operators :math:`\vec\Xi`.
These are set in the input ``.json`` file using either the ``"rTech"`` or ``"collOp"`` keywords as follows:

.. code-block:: console

    "collOp": <int value>

Where ``<int value>`` is an integer code corresponding to the desired collision operator.

In this section, we describe the various families of collision operators available in MPCD, state their associated keycodes, and describe the parameters they use.

.. _SRD:

Stochastic rotation dynamics
============================
The original implementation of MPCD is known as Stochastic Rotation Dynamics (SRD) [Gompper2009]_.
Translating to modern terminology, SRD's collision operator :math:`\vec\Xi` choses a random axis, around which it performs
a rotation through an angle :math:`\theta`. This is done by conservating energy, preserving isotropy and the Maxwell Boltzmann velocity distribution in the continuum limit.
This random rotation is what gives its this MPCD variant its name: Stochastic Rotation Dynamics (SRD). 

More formally, the SRD the collision operator is

.. math:: 
    :name: eq:SRD

    \vec{\Xi}_i^\mathrm{SRD}(t) = \Omega_\theta \cdot \left( 
        \vec{v}_i(t) - \vec{v}_{cm}(t)    
    \right)

in which :math:`\Omega_\theta` is a rotation tensor through an angle :math:`\theta` about a given axis, and :math:`\vec{v}_{cm}` is the center of mass velocity of the particles in the collision cell.

Being a 3D rotation tensor, :math:`\Omega_\theta` is defined as

.. math:: 
    :name: eq:SRD_rotation_tensor

    \begin{align}
        \Omega_\theta &= \begin{pmatrix}
            n_x^2+(1-n_x^2)\cos\theta & n_xn_y\left(1 - \cos\theta\right)-n_z \sin\theta & n_xn_z\left(1-\cos\theta\right)+n_y \sin\theta \\
            n_xn_y \left(1 - \cos\theta\right)+n_z \sin\theta & n_y^2 + \left(1-n_y^2\right)\cos\theta & n_yn_z \left(1 - \cos\theta\right)-n_x \sin\theta \\
            n_xn_z\left(1 - \cos\theta\right)-n_y \sin\theta & n_yn_z\left(1 - \cos\theta\right)+n_x \sin\theta  &n_z^2 + \left(1-n_z^2\right)\cos\theta 
        \end{pmatrix}, 
    \end{align}

in which the vector :math:`\hat{n} = [n_x, n_y, n_z]` defines a unit vector representing the axis of rotation.

A visual description of the algorithmic implementation of the SRD collision operator is shown below.

.. list-table:: 
    :header-rows: 0
    :widths: 50 50 50
    :align: center

    * - .. image:: ./CollisionOperators/SRD1.png
            :width: 95%
            :align: center
      - .. image:: ./CollisionOperators/SRD2.png
            :width: 95%
            :align: center
      - .. image:: ./CollisionOperators/SRD3.png
            :width: 95%
            :align: center
    * - **(a)** Bin MPCD particles into cells.
      - **(b)** Calculate the center of mass velocity :math:`\vec{v}^\mathrm{cm}` of the cell.
      - **(c)** For each MPCD particle, calculate the difference from :math:`\vec{v}^\mathrm{cm}`.
    * - .. image:: ./CollisionOperators/SRD4.png
            :width: 95%
            :align: center
      - .. image:: ./CollisionOperators/SRD5.png
            :width: 95%
            :align: center 
      - 
    * - **(d)** For each MPCD particle, generate a random unit vector :math:`\hat{n}^\mathrm{ran}`.
      - **(e)** Rotate each difference about :math:`\hat{n}^\mathrm{ran}` by :math:`\theta`.
      - 

The version of SRD in where :math:`\hat{n}` is chosen from the unit sphere is implemented with a keycode of ``0``. 
To use it add the following to your input ``.json`` file:

.. code-block:: console

    "collOp": 0

However, in order to reproduce in bulk a fluid with the correct hydrodynamic properties, it is sufficient to choose the axis of rotation :math:`\vec{\hat{n}}` randomly from the cartesian axes, i.e., :math:`\vec{\hat{n}} = [1, 0, 0]`, :math:`[0, 1, 0]` or :math:`[0, 0, 1]`, which increases the efficiency of the algorithm.

This version of SRD is implemented with a keycode of ``1``.
To use it add the following to your input ``.json`` file:

.. code-block:: console

    "collOp": 1

It is possible to verify that momentum and energy are conserved before and after collision by explicitly computing them.

.. _Andersen:

Andersen-thermostatted MPCD
===========================
While SRD is sufficient for some applications, it is not without its drawbacks:

- The SRD collision operator does not generally conserve angular momentum, as it does not consider the positions of particles within the cell.
- An explicit external thermostat is required to control the system energy when external forces or activity are applied.

Following other mesoscale simulation techniques, such as DPD, where a thermostat is included intrinsically as part of the simulation technique, thermostats have been incoroporated into MPCD collision operators.
That is, :math:`\vec\Xi` acts both as the collision operator and a local thermostat for the cell, such that no velocity rescaling techniques are necessary.

The primary thermostatted collision operator in this simulator is the Andersen thermostatted collision operator [Gompper2009]_, defined as

.. math:: 
    :name: eq:AndersenOp

    \vec{\Xi}_i^\mathrm{A}(t) = 
    \vec\xi_i -
    \frac{\sum_j^{N_C} m_j \vec\xi_j}{\sum_j^{N_C} m_j},
    
in which each component of :math:`\vec\xi_i` is randomly generated from a Gaussian distribution with variance :math:`\sqrt{k_B T/ m}`.

The final term in :ref:`the Andersen collision operator <eq:AndersenOp>` is referred to as the residual, and denoted :math:`\langle \vec\xi_j \rangle_{N_C}`. 
Each fluid particle in a given cell is assigned a new, randomly chosen velocity during each collision.
However, the presence of the residual means that each particle's velocity is a new randomly assigned value, minus the mass weighted velocity of all the new random values for that cell. This ensures that the center of mass velocity of each cell does not change during collision, ensuring moomentum conservation.

.. list-table:: 
    :header-rows: 0
    :widths: 50 50
    :align: center

    * - .. image:: ./CollisionOperators/Andersen1.png
            :width: 95%
            :align: center
      - .. image:: ./CollisionOperators/Andersen2.png
            :width: 95%
            :align: center
    * - **(a)** Bin MPCD particles into cells.
      - **(b)** Calculate the center of mass velocity :math:`\vec{v}^\mathrm{cm}` of the cell.
    * - .. image:: ./CollisionOperators/Andersen3.png
            :width: 95%
            :align: center
      - .. image:: ./CollisionOperators/Andersen4.png
            :width: 95%
            :align: center
    * - **(c)** For each MPCD particle, generate a random velocity that sums to :math:`\vec{v}^\mathrm{cm}`.
      - **(d)** Apply to each MPCD particle.

The Andersen thermostatted collision operator is implemented with a keycode of ``2``.
To use it, add the following to your input ``.json`` file:

.. code-block:: console

    "collOp": 2

Note that the :ref:`the basic Andersen collision operator <eq:AndersenOp>` conserves mass and translational momentum, but not angular momentum (or energy, as it is thermostatted).
However, it can be extended to do so. The basic Andersen collision operator introduces a small change in angular momentum every timestep, which we denote :math:`\delta \vec{L}`. 
This can be cancelled out by applying a small counter-rotation to each particle, such that the total angular momentum change is zero.
If the particles in the cell have a given intertia tensor :math:`I` about the center of mass, then the required counter-rotation required is :math:`\vec \omega = I^{-1} \cdot \delta \vec{L}`.

This correction is done by adding an extra term to the Andersen collision operator that performs this counter-rotation

.. math:: 
    :name: eq:AndersenOpAngular

    \vec{\Xi}_i^\mathrm{A}(t) = 
    \vec\xi_i -
    \langle \vec\xi_j \rangle_{N_C} +
    \left[
        I^{-1} \cdot \left(
            \sum_j^{N_C} m_j \left\lbrace
                \vec{x}'_j \times (\vec{v}_j - \vec\xi_j)
            \right\rbrace
        \right)
    \right] \times \vec{x}'_j,

in which \vec{x}'_j denotes the position of the particle with respect to the cell's cooridnate center of mass. 

.. note:: 
    The angular-conserving Andersen thermostatted collision operator above is the default, and preferred, collision operator in this MPCD simulator for traditional fluids.

The angular-conserving Andersen thermostatted collision operator is implemented with a keycode of ``3``.
To use it, add the following to your input ``.json`` file:

.. code-block:: console

    "collOp": 3

.. note:: 
    The angular-conserving Andersen thermostatted collision operator is the basis used for the :ref:`Nematic MPCD <chapter8>` algorithm.

.. note::
    MPCD can also simulate active nematics using the :ref:`Active Nematic MPCD <ActiveNematic>` algorithm.
