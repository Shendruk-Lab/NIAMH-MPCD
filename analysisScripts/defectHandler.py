"""
    A class to handle defects for the purposes of drawing. Currently 2D only.
    Started by Timofey Kozhukhov, April 2020.
    
    Please do not edit this file directory in child respositories, instead edit
        at the root!
    See the root repository here: https://github.com/Shendruk-Lab/MPCDDefectLoader
"""

from dataclasses import dataclass
import numpy as np
import matplotlib.pyplot as plt
import os
@dataclass
class Defect:
    """
    A dataclass to help handle defects found from topological charge.
    :param pos: Position of the defect
    :type pos: np.ndarray
    :param charge: Topological charge of the defect
    :type charge: float
    :param angle: Angle of the defect
    :type angle: float
    :param _defectGroup: Group of the defect (internal identifier)
    :type _defectGroup: int
    """
    pos : np.ndarray
    charge : float
    angle : float
    _defectGroup : int = -1

    def drawDefect(self, lineLength : float, lineWidth : float, stylePlus="r", 
                    styleMinus="b", pltObj = plt):
        """
        Draws a defect on a plot.

        :param lineLength: length of the lines used to draw the defect
        :type lineLength: float
        :param lineWidth: width of the lines used to draw the defect
        :type lineWidth: float
        :param stylePlus: style of lines used to draw +1/2 defects
        :param styleMinus: style of lines used to draw -1/2 defects
        :param pltObj: The axes to draw on
        """
        # Note, this only works for 2D plots, and makes no assumption for 
        #   slicing
        def drawLine(pos, angleRelDefect, length, style):
            x = pos[0] + length*np.cos(angleRelDefect+self.angle)
            y = pos[1] + length*np.sin(angleRelDefect+self.angle)
            return pltObj.plot([pos[0], x], [pos[1], y], style, lw=lineWidth)

        if self.charge > 0:
            # +1/2 defect
            drawLine(self.pos-0.5*lineLength*np.array(
                [np.cos(self.angle), np.sin(self.angle), 0]), 
                np.pi/6, lineLength * 1.5, stylePlus)
            drawLine(self.pos-0.5*lineLength*np.array(
                [np.cos(self.angle), np.sin(self.angle), 0]), 
                -np.pi/6, lineLength * 1.5, stylePlus)
        elif self.charge < 0: 
            # -1/2 defect
            drawLine(self.pos, 0, lineLength, styleMinus)
            drawLine(self.pos, 2*np.pi/3, lineLength, styleMinus)
            drawLine(self.pos, 4*np.pi/3, lineLength, styleMinus)

    def distTo(self, otherDefect, l = None):
        """
        Helper method. Get distance to another defect.

        :param otherDefect: Defect to get distance to
        :param l: box dimensions for PBC, can be 3d array. If None, no PBC
        :return: distance (scalar) to other defect
        """
        diff = self.pos - otherDefect.pos
        if l is None:
            return np.linalg.norm(diff)
        else:
            return np.linalg.norm(np.mod(diff + 0.5 * l, l) - 0.5 * l) # MIC

@dataclass
class TimestepDefectContainer:
    """
    Helper container object to store the defects for a single timestep

    :param time: The time value corresponding to this timestep
    :type time: float
    :param defects: A list of defects containing the defects for this timestep
    :type defects: list(Defect)
    """
    time: float 
    defectList : list
def readTopologicalFile(sysDim, infile):
    # topochargefield file part
    # data to return later
    timeStepList = []

    DEFECTIDARRAY = -1*np.ones((sysDim[0], sysDim[1], sysDim[2])) 
    # 3D array containing defect ID info, [x][y][z], default -1

    lastT = 0. #last Time measured
    DEFECTDATA = [] #list of defects on the current timestep

    error = False # error catching
    currLine = 14
    t = 0
    while infile: #loop through file to look for the target data we want
        line = infile.readline()
        def endTStep(t : float): # code to be run at the end of each timestep
            collatedDefect = _collapseDefects(DEFECTDATA, DEFECTIDARRAY, 
                sysDim)
            timeStepList.append(TimestepDefectContainer(t, collatedDefect))
        if (not line): #leave loop if EoF
            endTStep(t)
            break
        else:
            try:
                t,qx,qy,qz,charge,angle = line.split("\t", 6)
                t = float(t)
                charge = float(charge)
            except:
                error = True
                print("Error reading file "+dir+" on line +"+str(currLine))
                continue
            if t > lastT: # if there's a new timestep worth of data, prepare for the next block of data
                if not error: endTStep(t) # only append data if not error
                lastT = t                
                error = False
                DEFECTDATA = [] #clear defect data list
                DEFECTIDARRAY = -1*np.ones((sysDim[0], sysDim[1], sysDim[2]))  
                # 3D array containing defect ID info, [x][y][z], default -1
            if abs(abs(charge)-0.5) < 0.001: # if we have charge \pm 1/2 then we have a defect
                DEFECTDATA.append(Defect(pos=np.array([float(qx), float(qy), 
                    float(qz)]), charge=float(charge), angle=float(angle)))
                #add to the defect ID array too
                DEFECTIDARRAY[int(qx)][int(qy)][int(qz)] = len(DEFECTDATA) - 1
        currLine += 1
    return timeStepList

def readDefectsFile(infile):
    # defects.dat file part
    # data to return later
    timeStepList = []
    DEFECTDATA = [] #list of defects on the current timestep
    timeStepCaptured = False
    # defects.dat file part
    def captureTimestep():
        nonlocal DEFECTDATA, timeStepCaptured
        if DEFECTDATA or timeStepCaptured:
            timeStepList.append(TimestepDefectContainer(t, DEFECTDATA))
            timeStepCaptured = False
            DEFECTDATA = []
    while infile: 
        line = infile.readline()
        if (not line): #leave loop if EoF
            captureTimestep()
            break
        else:
            if (len(line.split("\t")) == 4):
                qx,qy,charge,angle = line.split("\t", 4)
                try:
                    DEFECTDATA.append(Defect(pos=np.array([float(qx), float(qy), 0.0]), charge=float(charge), angle=float(angle))) #another 0.0 for backward compatibility
                except Exception as e:
                    print("Error reading defect {} data: {}".format(line, e))
                    continue
            elif (len(line.split("\t")) == 2):
                t,_ = line.split("\t", 2)
                try:
                    t = float(t)
                except Exception as e:
                    print("Error reading time value from line: {}, {}".format(line, e))
                    continue
                timeStepCaptured = True
            else:
                captureTimestep()
    return timeStepList

def getDefectData(dir: str, sysDim):
    """
    Extracts defect data from a topology data file.

    :param dir: Path to the topology data file
    :type dir: str
    :param sysDim: Dimensions of the system domain as a list `[lx, ly, lz]`

    :return: List of `TimestepDefectContainer` objects containing the defects 
        at each timestep
    """
    assert(sysDim[2] == 1), "defectLoader only works for 2D"

    #load data file, cannot use numpy for this because of the data format
    file = dir
    infile = open(file, "r")

    for _ in range(13): #toss header
        line = infile.readline()

    # to handle defects.dat and topochargefield.dat    
    if os.path.basename(file).startswith("defects") and file.endswith(".dat"):
        timeStepList = readDefectsFile(infile)
    else:
        timeStepList = readTopologicalFile(sysDim, infile)
    
    infile.close()
    return timeStepList

#merge neighbouring defects of like charge together
def _collapseDefects(DEFECTDATA, DEFECTIDARRAY, sysDim):
    # a group of defects to be collated
    class DefectGroup:
        def __init__(self, groupID):
            self.charge = 0
            self.posList = [[], [], []] # stores as [index][elem]
            self.angles = []
            self.ID = groupID

        def addDefect(self, target : Defect):
            if self.charge != 0: # if charge is already set, do a check
                if self.charge != target.charge:
                    print("Trying to assign a defect of incorrect charge to group ID "+self.ID)
            else: #if charge not set, set charge
                self.charge = target.charge

            # add to posList and increment count
            for i,coord in enumerate(target.pos):
                self.posList[i].append(coord)

            # add to angle list
            self.angles.append(target.angle)

            # tag defect
            target._defectGroup = self.ID

        def getDefect(self): #convert a defect group back to a defect
            # get av x, y, z pos
            avX = sum(self.posList[0])/len(self.posList[0])
            avY = sum(self.posList[1])/len(self.posList[1])
            avZ = sum(self.posList[2])/len(self.posList[2])

            # get av angle - explicit average wont work in all cases
            unitVecList = []
            for angle in self.angles:
                unitVecList.append(np.array([np.cos(angle), np.sin(angle)]))
            avUnitVec = sum(unitVecList)/len(unitVecList)
            avAng = np.arctan2(avUnitVec[1], avUnitVec[0])

            return Defect(pos=np.array([avX, avY, avZ]), charge=self.charge, 
                angle=avAng)

    currGroupCount = 0 #init number of groups
    groupList = [] # list of current groups

    #loop through defects
    for i, defect in enumerate(DEFECTDATA):
        # method to check (and potentially add) neighbour to groupList
        def checkNeighbour(coord):
            # check list for neighbour ID
            qx = int(coord[0])
            qy = int(coord[1])
            qz = int(coord[2])
            nID = int(DEFECTIDARRAY[qx][qy][qz] )

            if nID != -1: #if there exists a defect there...
                if DEFECTDATA[nID].charge == defect.charge: #... of like charge
                    nDGroup = DEFECTDATA[nID]._defectGroup #get defect group
                    
                    if nDGroup != -1: #if nDGroup is assigned
                        groupList[nDGroup].addDefect(defect) #assign defect

                        return True # return true
                    else: return False
                else: return False
            else: return False #if no defect is there, return false

        # construct coordDiffs to check
        coord = defect.pos
        coordDiffs = []
        for xd in range(-1, 2):
            for yd in range(-1, 2):
                for zd in range(-1, 2):
                    x = coord[0]+xd
                    y = coord[1]+yd
                    z = coord[2]+zd

                    # check out of bounds
                    if (x < 0) or (x >= sysDim[0]):
                        continue
                    if (y < 0) or (y >= sysDim[1]):
                        continue
                    if (z < 0) or (z >= sysDim[2]):
                        continue

                    coordDiffs.append([x, y, z]) # if here then add
                
        status = False # whether we were assigned or not
        for coord in coordDiffs:
            status = checkNeighbour(coord) # consider each neighbours
            if status == True: # if succesfull then move onto next defect
                break
        
        #if we're here and still not assigned, then create a new group
        if status == False:
            groupList.append(DefectGroup(currGroupCount))
            groupList[-1].addDefect(defect)

            currGroupCount += 1 #increment group counter

    #export a dumped list of defects
    return [dg.getDefect() for dg in groupList]