<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Hard-coded options" href="../HardCoded/HardCoded.html" /><link rel="prev" title="Tutorials" href="../Tutorials/Tutorials.html" />

    <link rel="shortcut icon" href="../_static/niamh-favicon.png"/><!-- Generated with Sphinx 5.3.0 and Furo 2023.03.27 -->
        <title>MPCD usage - NIAMH-MPCD documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=fad236701ea90a88636c2a8c73b44ae642ed2a53" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">NIAMH-MPCD  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../_static/niamh-logo.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">NIAMH-MPCD  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Summary/Summary.html">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Algorithm/Algorithm.html">Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Install/Install.html">Installation guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Install/Run.html">Run guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Input/inputFiles.html">Input guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">MPCD usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HardCoded/HardCoded.html">Hard-coded options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Inclusions/Inclusions.html">Inclusions and solutes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ExtraTheory/ExtraTheory.html">Additional theoretical background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Outputs/Outputs.html">Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Analysis/Analysis.html">Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DeveloperGuide/DeveloperGuide.html">Developer’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../References/References.html">Bibliography</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="mpcd-usage">
<span id="usagechapter"></span><h1><a class="toc-backref" href="#id40" role="doc-backlink">MPCD usage</a><a class="headerlink" href="#mpcd-usage" title="Permalink to this heading">#</a></h1>
<p>NIAMH-MPCD sets its particle properties, cell properties, initialization, boundary conditions, etc. through json input files (see the <a class="reference internal" href="../Install/Run.html#runguide"><span class="std std-ref">Input guide</span></a> for command line arguments to provide input files to the code and the <a class="reference internal" href="../Input/inputFiles.html#inputguide"><span class="std std-ref">Input json files</span></a> section for details on the json format).
The <a class="reference internal" href="../Tutorials/Tutorials.html#tutorials"><span class="std std-ref">Tutorials</span></a> provide different example input files for specific simulations.
The following sections provide a detailed review of the different input parameters in these files.</p>
<nav class="contents this-will-duplicate-information-and-it-is-still-useful-here" id="usage">
<p class="topic-title">Usage</p>
<ul class="simple">
<li><p><a class="reference internal" href="#mpcd-usage" id="id40">MPCD usage</a></p>
<ul>
<li><p><a class="reference internal" href="#system-properties" id="id41">System properties</a></p></li>
<li><p><a class="reference internal" href="#mpcd-particle-properties" id="id42">MPCD particle properties</a></p></li>
<li><p><a class="reference internal" href="#mpcd-cell-properties" id="id43">MPCD cell properties</a></p></li>
<li><p><a class="reference internal" href="#collision-operators" id="id44">Collision operators</a></p></li>
<li><p><a class="reference internal" href="#boundary-conditions" id="id45">Boundary conditions</a></p></li>
<li><p><a class="reference internal" href="#extra-options" id="id46">Extra options</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="system-properties">
<span id="chaptersimulations"></span><h2><a class="toc-backref" href="#id41" role="doc-backlink">System properties</a><a class="headerlink" href="#system-properties" title="Permalink to this heading">#</a></h2>
<p>All NIAMH-MPCD simulations have the following properties and they should be initialized in the input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file.</p>
<section id="domain">
<span id="systemdomain"></span><h3>Domain<a class="headerlink" href="#domain" title="Permalink to this heading">#</a></h3>
<p>The system domain is set by giving an array, given as <code class="docutils literal notranslate"><span class="pre">[X,</span> <span class="pre">Y]</span></code> or <code class="docutils literal notranslate"><span class="pre">[X,</span> <span class="pre">Y,</span> <span class="pre">Z]</span></code>.
If the array has a length of two, the system is assumed to be 2D. If it has a length of three, it is 3D. Other lengths are not permitted. A 2D system corresponds to a <code class="docutils literal notranslate"><span class="pre">[X,Y,1]</span></code> domain.</p>
<p>Setting the domain does <strong>not</strong> set the boundary conditions. That must be done separately as explained in the <a class="reference internal" href="#chapterbc"><span class="std std-ref">BC</span></a> section.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;domain&quot;</span><span class="p">:</span><span class="w">   </span><span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">30</span><span class="p">],</span>
</pre></div>
</div>
</section>
<section id="thermal-energy">
<span id="kbt"></span><h3>Thermal energy<a class="headerlink" href="#thermal-energy" title="Permalink to this heading">#</a></h3>
<p>Many MPCD <a class="reference internal" href="#chaptercollop"><span class="std std-ref">collision operators</span></a> are thermostatted and those that conserve energy are initialized by the thermal energy <span class="math notranslate nohighlight">\(k_B T\)</span>, where <span class="math notranslate nohighlight">\(k_B\)</span> is the Boltzmann constant and <span class="math notranslate nohighlight">\(T\)</span> is the temperature.
The thermal energy is also used in non-collision operator <a class="reference internal" href="#thermostats"><span class="std std-ref">thermostats</span></a>. To set the thermal energy, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;kbt&quot;</span><span class="p">:</span><span class="w">   </span><span class="mf">1.0</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The default value = 1 and it should be <strong>always</strong> be 1 since it sets the energy scale (see <a class="reference internal" href="../Algorithm/Algorithm.html#set-values"><span class="std std-ref">units</span></a>).</p>
</div>
</section>
<section id="timestep">
<span id="id1"></span><h3>Timestep<a class="headerlink" href="#timestep" title="Permalink to this heading">#</a></h3>
<p>The MPCD algorithm iterates streaming and collision operations over discrete timesteps <span class="math notranslate nohighlight">\(\delta t\)</span>. The timestep <span class="math notranslate nohighlight">\(\delta t\)</span> does <strong>not</strong> define the units of time (see <a class="reference internal" href="../Algorithm/Algorithm.html#derivedunits"><span class="std std-ref">Derived units</span></a>) and so it can take any value. To set the timestep, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;dt&quot;</span><span class="p">:</span><span class="w">   </span><span class="mf">0.1</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value <span class="math notranslate nohighlight">\(\delta t= 0.1\)</span>. Typically values less than or equal to 1 are best. Decreasing the timestep increases the viscosity (see <a class="reference internal" href="../ExtraTheory/ExtraTheory.html#viscositysection"><span class="std std-ref">Transport coefficients</span></a>).</p>
</div>
</section>
<section id="simulation-steps">
<span id="simsteps"></span><h3>Simulation steps<a class="headerlink" href="#simulation-steps" title="Permalink to this heading">#</a></h3>
<p>The MPCD code iterates for a number of time steps. To set the duration of a simulation, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;simSteps&quot;</span><span class="p">:</span><span class="w">   </span><span class="mi">1000000</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Like all times in the <code class="docutils literal notranslate"><span class="pre">input.json</span></code> file is in number of iterations <span class="math notranslate nohighlight">\(\delta t\)</span>, <strong>not</strong> simulation units of time <span class="math notranslate nohighlight">\([\tau]\)</span>.</p>
</div>
</section>
<section id="warmup-steps">
<span id="warmup"></span><h3>Warmup steps<a class="headerlink" href="#warmup-steps" title="Permalink to this heading">#</a></h3>
<p>The MPCD code can iterate for a number of time steps prior to writing out data. To set the duration of this warmup phase of the simulation, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;warmUp&quot;</span><span class="p">:</span><span class="w">   </span><span class="mi">50000</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">warmup</span></code> duration is in addition to the <code class="docutils literal notranslate"><span class="pre">simSteps</span></code> duration.</p>
</div>
</section>
<section id="random-number-seed">
<span id="seed"></span><h3>Random number seed<a class="headerlink" href="#random-number-seed" title="Permalink to this heading">#</a></h3>
<p>The MPCD algorithm relies on generating many random numbers. The seed for the <a class="reference internal" href="../HardCoded/HardCoded.html#randnumgen"><span class="std std-ref">random number generator</span></a> can be set by adding the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;seed&quot;</span><span class="p">:</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span>
</pre></div>
</div>
<p>If the seed is set to zero (which is the default) then a pseudorandom seed is generated through a combination of microseconds on the clock and processor task ID. The seed is outputted in <code class="docutils literal notranslate"><span class="pre">synopsis.dat</span></code> (see <a class="reference internal" href="../Outputs/Outputs.html#id1"><span class="std std-ref">Outputs</span></a>). If the <code class="docutils literal notranslate"><span class="pre">seed</span></code> is set to -1, the simulation starts from a checkpoint.</p>
</section>
<section id="nematic-fluid">
<span id="nematicon"></span><h3>Nematic fluid<a class="headerlink" href="#nematic-fluid" title="Permalink to this heading">#</a></h3>
<p>When simulating a fluctuating nematic liquid crystal, the simulation has to be told. Set whether or not the fluid is isotropic or nematic using the <code class="docutils literal notranslate"><span class="pre">&quot;lc&quot;</span></code> tag:</p>
<ul class="simple">
<li><p>Isotropic fluid</p></li>
</ul>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;lc&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">0</span><span class="p">,</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Nematic fluid using local orientational order</p></li>
</ul>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;lc&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Nematic fluid using global orientational order</p></li>
</ul>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;lc&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">2</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>All other nematic particle parameters are fluid-species specific and are set in the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array.</p></li>
<li><p>MPCD particles must be given additional properties due to their nematic orientational symmetry <strong>inside</strong> the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array. The nematic-MPCD algorithm and parameters are explained in the <a class="reference internal" href="#nemcollop"><span class="std std-ref">nematic collision Operator section</span></a>.</p></li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The option to use global orientation for simulating nematics amounts to using a mean field approximation in the collision operation. The local version should be prefered (i.e. <code class="docutils literal notranslate"><span class="pre">&quot;lc&quot;:</span> <span class="pre">1</span></code>).</p>
</div>
</section>
<section id="multiphase">
<span id="multiphaseparticles"></span><h3>Multiphase<a class="headerlink" href="#multiphase" title="Permalink to this heading">#</a></h3>
<p>MPCD particles can belong to different fluid-species to induce multi-phases.</p>
<p>Set whether or not the fluid is multiphase using the <code class="docutils literal notranslate"><span class="pre">&quot;multiphase&quot;</span></code> tag:</p>
<ul class="simple">
<li><p>Single phase</p></li>
</ul>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;multiphase&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">0</span><span class="p">,</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Multiphase interactions via a surface fitter-version</p></li>
</ul>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;multiphase&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Multiphase interactions via a point gradient-version.</p></li>
</ul>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;multiphase&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">2</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All other multiphase particle parameters are fluid-species specific and are set in the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array as described in the <a class="reference internal" href="#multiphasecollop"><span class="std std-ref">Multiphase collision operators</span></a>.</p>
</div>
</section>
<section id="galilean-invariance">
<span id="galilean"></span><h3>Galilean invariance<a class="headerlink" href="#galilean-invariance" title="Permalink to this heading">#</a></h3>
<p>By discretizing the space into cells, <strong>Galilean invariance</strong> is broken <a class="reference internal" href="../References/References.html#ihle2003" id="id2"><span>[Ihle2003]</span></a>.
To understand why, consider a simulation of slow moving fluid particles (low temperatures).
If the mean-free path of the molecules (see <a class="reference internal" href="../ExtraTheory/ExtraTheory.html#chaptervisc"><span class="std std-ref">Viscosity</span></a>) is much smaller than the cell size (<span class="math notranslate nohighlight">\(\lambda \ll a\)</span>) then particles will often fail to travel far enough to leave the cell and may repeatedly exchange momentum with the same set of neighbours.
Thus, the implicit assumption of underlying molecular chaos fails and the fixed lattice of cells causes the behaviour in a moving reference frame to be different than a fixed reference frame, since in the moving frame the set of neighbours would be different in each (fig{fig:galInv}).
However, Galilean invariance can be completely reestablished by shifting the cell grid each time step by a random vector.
Galilean invariance is then remedied.
Practically speaking, this is implemented by shifting all the fluid particles by the same vector whose components were chosen at random from the interval <span class="math notranslate nohighlight">\(\left[-a/2,a/2\right]\)</span>.</p>
<figure class="align-center" id="id37">
<a class="reference internal image-reference" href="../_images/galileanInv.png"><img alt="Logo" src="../_images/galileanInv.png" style="width: 365.7px; height: 376.5px;" /></a>
<figcaption>
<p><span class="caption-text">Galilean invariance is restored by randomly shifting the lattice of MPCD cells.</span><a class="headerlink" href="#id37" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Set whether or not to apply the Galilean invariance shift using the <code class="docutils literal notranslate"><span class="pre">&quot;galInv&quot;</span></code> tag <strong>outside</strong> of the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array:</p>
<ul class="simple">
<li><p>On</p></li>
</ul>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;galInv&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Off</p></li>
</ul>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;galInv&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">0</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 1.</p>
</div>
</section>
<section id="terminal-output">
<span id="debugout"></span><h3>Terminal output<a class="headerlink" href="#terminal-output" title="Permalink to this heading">#</a></h3>
<p>The verbosity of the information that NIAMH-MPCD writes to the terminal can be controlled.  To set the verbosity, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;debugOut&quot;</span><span class="p">:</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span>
</pre></div>
</div>
<dl class="simple">
<dt>Common choices are:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> Outputs nothing but acknowledgement that the simulation has started and ended. This Debug/verbosity level should be used for data collection runs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> Only outputs warnings.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> Outputs initialisation information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> Outputs an acknowledgement of each eteration step.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4</span></code> Gives a title to some methods and outputs them when called.</p></li>
<li><p>Higher numbers are specific to certain aspects of the code and may be useful for debugging. Please see <a class="reference internal" href="../HardCoded/HardCoded.html#verbosity"><span class="std std-ref">Debug modes/verbosity</span></a> and <code class="docutils literal notranslate"><span class="pre">mpcd/headers/definitions.h</span></code> for a complete list.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 3.</p>
</div>
</section>
</section>
<section id="mpcd-particle-properties">
<span id="chapterparticles"></span><h2><a class="toc-backref" href="#id42" role="doc-backlink">MPCD particle properties</a><a class="headerlink" href="#mpcd-particle-properties" title="Permalink to this heading">#</a></h2>
<p>MPCD fluid is made of point-like particles and based on the fluid type they have different properties.
Fluid particle properties are typically set within the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array (see <a class="reference internal" href="../Input/inputFiles.html#speciesinput"><span class="std std-ref">Species tag table</span></a>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;species&quot;</span><span class="p">:</span>
<span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">&quot;comment&quot;</span><span class="p">:</span> <span class="s2">&quot;MPCD species 1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;tag&gt;&quot;</span><span class="p">:</span>  <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="o">...</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">&quot;comment&quot;</span><span class="p">:</span> <span class="s2">&quot;MPCD species 2&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;tag&gt;&quot;</span><span class="p">:</span>  <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">],</span>
</pre></div>
</div>
<section id="isotropic-fluid">
<h3>Isotropic fluid<a class="headerlink" href="#isotropic-fluid" title="Permalink to this heading">#</a></h3>
<p>Any fluid solved with MPCD particles has the following properties and they should be initialized in the input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file.</p>
<section id="position-initialization">
<span id="position"></span><h4>Position initialization<a class="headerlink" href="#position-initialization" title="Permalink to this heading">#</a></h4>
<p>Each particle has a position vector, <span class="math notranslate nohighlight">\({\vec x}_i\)</span>, pointing to its position in the control volume.</p>
<p><code class="docutils literal notranslate"><span class="pre">&quot;qdist&quot;</span></code> specifies how the position of this fluid-species’ particles are initialised and should be set <strong>inside</strong> the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array for each fluid-species. The available options are to:</p>
<ul>
<li><p>place the particles randomly and freely within the control volume.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;qdist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">0</span><span class="p">,</span>
</pre></div>
</div>
</li>
<li><p>read the particles’ positions from a file.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;qdist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0.</p>
</div>
</section>
<section id="velocity-initialization">
<span id="velocity"></span><h4>Velocity initialization<a class="headerlink" href="#velocity-initialization" title="Permalink to this heading">#</a></h4>
<p>Each particle has a velocity vector, <span class="math notranslate nohighlight">\({\vec v}_i\)</span>. <code class="docutils literal notranslate"><span class="pre">&quot;vdist&quot;</span></code> specifies how the velocity of this fluid-species’ particles is initialised and should be set <strong>inside</strong> the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array for each fluid-species. The available options are to:</p>
<ul>
<li><p>draw the velocity from an uniformly random distribution. The width of the uniform distribution is <span class="math notranslate nohighlight">\((2 k_\text{B}T/m)^{1/2}\)</span> for each component.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;vdist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">0</span><span class="p">,</span>
</pre></div>
</div>
</li>
<li><p>read the particles’ velocities from a file.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;vdist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This option is not currently operational.</p>
</div>
</li>
<li><p>give all the particles the same initial speed but in different directions.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;vdist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">2</span><span class="p">,</span>
</pre></div>
</div>
</li>
<li><p>give all the particles the same initial speed along each axis in either direction.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;vdist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">3</span><span class="p">,</span>
</pre></div>
</div>
</li>
<li><p>draw the particles’ velocity from a Gaussian distribution scaled by <span class="math notranslate nohighlight">\((k_\text{B}T/m)^{1/2}\)</span> for each component of the velocity.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;vdist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">4</span><span class="p">,</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0.</p>
</div>
</section>
<section id="mass">
<span id="id3"></span><h4>Mass<a class="headerlink" href="#mass" title="Permalink to this heading">#</a></h4>
<p>Each MPCD particle is assigned a mass specifing its contribution in the velocity collision step, when its momentum is exchanged with other particles belonging to the same cell. To set the species mass, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file <strong>inside</strong> the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array for each fluid-species:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;mass&quot;</span><span class="p">:</span><span class="w">   </span><span class="mf">1.0</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The default value = 1 and it should be <strong>always</strong> be 1 for at least one fluid-species since it sets the mass scale (see <a class="reference internal" href="../Algorithm/Algorithm.html#set-values"><span class="std std-ref">units</span></a>).</p>
</div>
</section>
<section id="population">
<span id="id4"></span><h4>Population<a class="headerlink" href="#population" title="Permalink to this heading">#</a></h4>
<p>It is the total population of the particles <span class="math notranslate nohighlight">\(N_\text{tot}\)</span> for each fluid-species. To set the population, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file <strong>inside</strong> the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array for each fluid-species:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;pop&quot;</span><span class="p">:</span><span class="w">   </span><span class="mi">100000</span><span class="p">,</span>
</pre></div>
</div>
<p>The total population sets the average number <span class="math notranslate nohighlight">\(\left\langle N_c \right\rangle\)</span> of particles per cell for each fluid-species and dividing by the number of accessible MPCD cells in the control volume sets the number density <span class="math notranslate nohighlight">\(\left\langle n_c \right\rangle\)</span>. If all fluid-species particles have the same <a class="reference internal" href="../Algorithm/Algorithm.html#set-values"><span class="std std-ref">unit mass</span></a> then the number density is equivalent to the mass density <span class="math notranslate nohighlight">\(\rho_c(t)\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">&quot;pop&quot;</span></code> can be overriden with <code class="docutils literal notranslate"><span class="pre">&quot;dens&quot;</span></code>.</p>
</div>
</section>
<section id="number-density">
<span id="density"></span><h4>Number density<a class="headerlink" href="#number-density" title="Permalink to this heading">#</a></h4>
<p>The population <code class="docutils literal notranslate"><span class="pre">&quot;pop&quot;</span></code> can be overriden for a given fluid-species population to correspond by setting the number density <span class="math notranslate nohighlight">\(\left\langle n_c \right\rangle\)</span> directly. This override sets the population to the accessible volume <span class="math notranslate nohighlight">\(V\)</span> times the density,</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[N_\text{tot} = V \left\langle n_c \right\rangle .\]</div>
</div>
<p>The volume <span class="math notranslate nohighlight">\(V\)</span> is the volume accessible to this particular species (i.e. volume of the domain, minus any excluded regions due to BCs).
Determining the accessible volume is done via a Monte Carlo integrator.
Because it uses Monte Carlo, the actually integer population <span class="math notranslate nohighlight">\(N_\text{tot}\)</span> of different realizations may vary minutely between runs.</p>
<p>To set the number density, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file  <strong>inside</strong> the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array for each fluid-species:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;dens&quot;</span><span class="p">:</span><span class="w">   </span><span class="mi">20</span><span class="p">,</span>
</pre></div>
</div>
</section>
<section id="orientation-initialization">
<span id="orientationparticles"></span><h4>Orientation initialization<a class="headerlink" href="#orientation-initialization" title="Permalink to this heading">#</a></h4>
<p>When simulating a nematic liquid crystal, each MPCD particle <span class="math notranslate nohighlight">\(i\)</span> is assigned an orientation <span class="math notranslate nohighlight">\({\vec u}_i\)</span>. Each fluid-species of MPCD particle must have its orientations initialized and should be set <strong>inside</strong> the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array for each fluid-species. The available options are:</p>
<ul>
<li><p>isotropically</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;odist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">0</span><span class="p">,</span>
</pre></div>
</div>
<ul class="simple">
<li><p>3D: Sample the z component on <span class="math notranslate nohighlight">\([{\cos(\pi)}, 1]\)</span> and then sample the azimuthal angle, <span class="math notranslate nohighlight">\({\phi}\)</span> on <span class="math notranslate nohighlight">\([0, 2{\pi})\)</span>.</p></li>
<li><p>2D: Simply sample the azimuthal angle homogeneously.</p></li>
<li><p>1D: Checks if <span class="math notranslate nohighlight">\({\cos(\phi)}\)</span> would be parallel or anti-parallel, returning +1.0 or -1.0.</p></li>
</ul>
</li>
<li><p>align all particles along X axis</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;odist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
</li>
<li><p>align all particles along Y axis</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;odist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">2</span><span class="p">,</span>
</pre></div>
</div>
</li>
<li><p>align all particles along Z axis</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;odist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">3</span><span class="p">,</span>
</pre></div>
</div>
</li>
<li><p>align all particles along 45 degree angle</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;odist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">4</span><span class="p">,</span>
</pre></div>
</div>
</li>
<li><p>align all particles randomly within XY axis</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;odist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">5</span><span class="p">,</span>
</pre></div>
</div>
</li>
<li><p>align all particles randomly within XZ axis</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;odist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">6</span><span class="p">,</span>
</pre></div>
</div>
</li>
<li><p>align all particles randomly within YZ axis</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;odist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">7</span><span class="p">,</span>
</pre></div>
</div>
</li>
<li><p>align all particles in the direction of origin towards positive right hand corner of any cartesian plan</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;odist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">8</span><span class="p">,</span>
</pre></div>
</div>
</li>
<li><p>align all particles in the direction of two oppositely charged defects</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;odist&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">9</span><span class="p">,</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 2.</p>
</div>
</section>
</section>
</section>
<section id="mpcd-cell-properties">
<span id="chaptercell"></span><h2><a class="toc-backref" href="#id43" role="doc-backlink">MPCD cell properties</a><a class="headerlink" href="#mpcd-cell-properties" title="Permalink to this heading">#</a></h2>
<p>Though particle properties are continuous, collision events occur on a descretized lattice of cells.
The simulation domain is partitioned into a <span class="math notranslate nohighlight">\(d\)</span>-dimensional square lattice of lattice size <span class="math notranslate nohighlight">\(a\)</span>.
Each cell <span class="math notranslate nohighlight">\(c\)</span> within the lattice has a number of properties and instantaneous averages within the cells are interpretted as the hydrodynamic values of the discretized macroscopic fields.</p>
<section id="cell-size">
<span id="cellsize"></span><h3>Cell size<a class="headerlink" href="#cell-size" title="Permalink to this heading">#</a></h3>
<p>The MPCD collisions occur on a square/cubic lattice with lattice constant <span class="math notranslate nohighlight">\(a=1\)</span>. The lattice size sets the <a class="reference internal" href="../Algorithm/Algorithm.html#set-values"><span class="std std-ref">units of length for the simulation</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While users are strongly encouraged to keep the fundamental units of mass <span class="math notranslate nohighlight">\(m=1\)</span> and energy <span class="math notranslate nohighlight">\(k_\text{B}T=1\)</span>, you do have the ability to change these. However, the lattice constant <strong>cannot be changed</strong>. This is so that integer operations can be used to bin particles into MPCD cells for collision events.</p>
</div>
</section>
<section id="numberincell">
<span id="id5"></span><h3>Number density<a class="headerlink" href="#numberincell" title="Permalink to this heading">#</a></h3>
<p>Each cell <span class="math notranslate nohighlight">\(c\)</span> has an instantaneous number of MPCD particles <span class="math notranslate nohighlight">\(N_c(t)\)</span>.
Since the cells have a lattice size <span class="math notranslate nohighlight">\(a=1\)</span>, the instantaneous number is equivalent to the number density <span class="math notranslate nohighlight">\(n_c(t)=N_c(t)/a^d\)</span>, where <span class="math notranslate nohighlight">\(d\)</span> is the dimensionality.</p>
<p>If the mass of all the fluid-particles is set to <a class="reference internal" href="../Algorithm/Algorithm.html#set-values"><span class="std std-ref">unit mass</span></a> <span class="math notranslate nohighlight">\(m=1\)</span>, then then the instantaneous number is also equivalent to the mass <span class="math notranslate nohighlight">\(M_c(t) = m N_c(t)\)</span> and the mass density <span class="math notranslate nohighlight">\(\rho_c(t) = M_c(t)/a^d\)</span>. However, if non-MPCD fluid particles are included in the collision event (such as monomers from <a class="reference internal" href="../Inclusions/Inclusions.html#chapter11"><span class="std std-ref">molecular dynamics</span></a> or <a class="reference internal" href="../Inclusions/Inclusions.html#swimmers"><span class="std std-ref">TADPole swimmers</span></a>), then the mass of those particles is also be included.</p>
</section>
<section id="center-of-mass-velocity">
<h3>Center of mass velocity<a class="headerlink" href="#center-of-mass-velocity" title="Permalink to this heading">#</a></h3>
<p>The center of mass velocity of the <span class="math notranslate nohighlight">\(N_c(t)\)</span> particles that are instantaneously in cell :math`c` is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\vec{v}_c(t) = \left\langle \vec{v}_i \right\rangle = \frac{\sum_i^{N_c} m_i \vec{v}_i(t)}{\sum_i^{N_c} m_i} .\]</div>
</div>
<p>In MPCD, the centre of mass velocity of the cells is interpretted as the hydrodynamic-scale velocity field <span class="math notranslate nohighlight">\(\vec{v}(\vec{r},t)\)</span>.</p>
</section>
<section id="center-of-mass">
<span id="cmofcell"></span><h3>Center of mass<a class="headerlink" href="#center-of-mass" title="Permalink to this heading">#</a></h3>
<p>The center of mass position of the <span class="math notranslate nohighlight">\(N_c(t)\)</span> particles that are instantaneously in cell :math`c` is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\vec{r}_c(t) = \left\langle \vec{r}_i \right\rangle = \frac{\sum_i^{N_c} m_i \vec{r}_i(t)}{\sum_i^{N_c} m_i} .\]</div>
</div>
</section>
<section id="moment-of-inertia">
<span id="momofintertia"></span><h3>Moment of inertia<a class="headerlink" href="#moment-of-inertia" title="Permalink to this heading">#</a></h3>
<p>The moment of inertia of the <span class="math notranslate nohighlight">\(N_c(t)\)</span> particles that are instantaneously in cell :math`c` is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\boldsymbol{I}_c(t) = \sum_i^{N_c} m_i (\vec{r}_i-\vec{r}_c) \otimes (\vec{r}_i-\vec{r}_c) .\]</div>
</div>
</section>
<section id="nematic-order">
<span id="nematicincell"></span><h3>Nematic order<a class="headerlink" href="#nematic-order" title="Permalink to this heading">#</a></h3>
<p>Nematic fluids are composed of particles with an orientation <span class="math notranslate nohighlight">\({\vec u}_i\)</span> and cells have local orientational order measured by the tensor order parameter</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\boldsymbol{Q}_{c}(t) = {\frac {1}{d-1}} &lt; d {\vec u}_i \otimes {\vec u}_i - {\hat 1}&gt;_{N_c}\]</div>
</div>
<p>of the cell <span class="math notranslate nohighlight">\(c\)</span>. For a nematic fluid, the largest eigenvalue of this tensor order is the local scalar order parameter, <span class="math notranslate nohighlight">\(S_c(t)\)</span>, of the cell and the local director, <span class="math notranslate nohighlight">\(\vec{n}_c(t)\)</span>, is parallel to the corresponding eigenvector.</p>
</section>
<section id="local-velocity-gradient-tensor">
<span id="velgrad"></span><h3>Local velocity gradient tensor<a class="headerlink" href="#local-velocity-gradient-tensor" title="Permalink to this heading">#</a></h3>
<p>The local velocity gradient <span class="math notranslate nohighlight">\(\vec{\nabla}\vec{v}_c\)</span> is needed for nematic-MPCD to allow the local director to respond to the flow field. The D3Q15 and D2Q9 gradients are used for three and two dimensions, respectively.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>NIAMH-MPCD (and MPCD in general) attempts to keep all operations on the level of a single cell, with no information exchange between cells (except through the <a class="reference internal" href="../Algorithm/Algorithm.html#streaming"><span class="std std-ref">streaming step</span></a>). However, the velocity gradient tensor is necessary for nematic-MPCD.</p>
</div>
</section>
</section>
<section id="collision-operators">
<span id="chaptercollop"></span><h2><a class="toc-backref" href="#id44" role="doc-backlink">Collision operators</a><a class="headerlink" href="#collision-operators" title="Permalink to this heading">#</a></h2>
<p>The cell-based collision operator lies at the heart of the <a class="reference internal" href="../Algorithm/Algorithm.html#collision"><span class="std std-ref">MPCD method</span></a>. During the collision operation momentum is transferred between fluid particles, under the constraint that the total local momuntum is conserved.</p>
<p>After streaming, all particles are binned into <a class="reference internal" href="#chaptercell"><span class="std std-ref">cells</span></a> (labelled <span class="math notranslate nohighlight">\(c\)</span>) and all the particles in a given cell are said to <em>collide</em>, locally exchanging particle properties via a stochastic collision operation.
It is this “multi-particle” collision operation that gives MPCD a computational speedup compared to algorithms that must calculate forces between all pairs of particles.
The collision step is typically a non-physical scheme constructed to be simple and stochastic, but also obey approprite conservation laws (such as conservation of momentum, angular momentum and/or energy/temperature) within each cell.</p>
<p>Multi-particle collisions within cells are represented by the collision operator <span class="math notranslate nohighlight">\(\vec{\Xi}\)</span>, which causes the velocity of MPCD-fluid particle <span class="math notranslate nohighlight">\(i\)</span> to become</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\vec{v}_i\left(t + \delta t\right) = \vec{v}^{c}\left(t\right) + \vec{\Xi} \left( \; \vec{v}_i\left(t\right), \vec{v}^{c}\left(t\right) \; \right) ,\]</div>
</div>
<p>where the velocities <span class="math notranslate nohighlight">\(\vec{v}_i\left(t\right)\)</span> and <span class="math notranslate nohighlight">\(\vec{v}_i\left(t+\delta t\right)\)</span> are the before and after values, and <span class="math notranslate nohighlight">\(\vec{v}^{c}\)</span> is the centre of mass velocity of cell <span class="math notranslate nohighlight">\(c\)</span>.</p>
<p>NIAMH-MPCD supports over twenty collision operators <span class="math notranslate nohighlight">\(\vec{\Xi}\)</span>.
These are set in the input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file using either the <code class="docutils literal notranslate"><span class="pre">&quot;rTech&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;collOp&quot;</span></code> keywords as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;collOp&quot;</span><span class="p">:</span> <span class="o">&lt;</span><span class="nb">int</span> <span class="n">value</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">&lt;int</span> <span class="pre">value&gt;</span></code> is an integer code corresponding to the desired collision operator.</p>
<section id="stochastic-rotation-dynamics">
<span id="srd"></span><h3>Stochastic rotation dynamics<a class="headerlink" href="#stochastic-rotation-dynamics" title="Permalink to this heading">#</a></h3>
<p>The original implementation of MPCD is known as Stochastic Rotation Dynamics (SRD) <a class="reference internal" href="../References/References.html#malevanets1999" id="id6"><span>[Malevanets1999]</span></a>.
SRD’s collision operator choses a random axis, around which it performs a rotation through an angle <span class="math notranslate nohighlight">\(\theta\)</span>. This conserves energy, preserving isotropy and the Maxwell-Boltzmann velocity distribution in the continuum limit.
This random rotation is what gives its this MPCD variant its name: Stochastic Rotation Dynamics (SRD).</p>
<p>The SRD the collision operator is</p>
<div class="math-wrapper docutils container" id="eq-srd">
<span id="equation-eq-srd"></span><div class="math notranslate nohighlight" id="eq-srd">
<span id="equation-eq-srd"></span><span class="eqno">(1)<a class="headerlink" href="#eq-srd" title="Permalink to this equation">#</a></span>\[\vec{\Xi}^\mathrm{SRD}(t) = \boldsymbol{\Omega}_\theta \cdot \left(
    \vec{v}_i(t) - \vec{v}_{cm}(t)
\right)\]</div>
</div>
<p>in which <span class="math notranslate nohighlight">\(\boldsymbol{\Omega}_\theta\)</span> is a rotation tensor through an angle <span class="math notranslate nohighlight">\(\theta\)</span> about a given axis, and <span class="math notranslate nohighlight">\(\vec{v}_{cm}\)</span> is the center of mass velocity of the particles in the collision cell.
In 3D, the rotation tensor is</p>
<div class="math-wrapper docutils container" id="eq-srd-rotation-tensor">
<span id="equation-eq-srd-rotation-tensor"></span><div class="math notranslate nohighlight" id="eq-srd-rotation-tensor">
<span id="equation-eq-srd-rotation-tensor"></span><span class="eqno">(2)<a class="headerlink" href="#eq-srd-rotation-tensor" title="Permalink to this equation">#</a></span>\[\begin{split}\begin{align}
    \boldsymbol{\Omega}_\theta &amp;= \begin{pmatrix}
        n_x^2+(1-n_x^2)\cos\theta &amp; n_xn_y\left(1 - \cos\theta\right)-n_z \sin\theta &amp; n_xn_z\left(1-\cos\theta\right)+n_y \sin\theta \\
        n_xn_y \left(1 - \cos\theta\right)+n_z \sin\theta &amp; n_y^2 + \left(1-n_y^2\right)\cos\theta &amp; n_yn_z \left(1 - \cos\theta\right)-n_x \sin\theta \\
        n_xn_z\left(1 - \cos\theta\right)-n_y \sin\theta &amp; n_yn_z\left(1 - \cos\theta\right)+n_x \sin\theta  &amp;n_z^2 + \left(1-n_z^2\right)\cos\theta
    \end{pmatrix},
\end{align}\end{split}\]</div>
</div>
<p>in which the vector <span class="math notranslate nohighlight">\(\hat{n} = [n_x, n_y, n_z]\)</span> defines a unit vector representing the axis of rotation.</p>
<p>A visual description of the algorithmic implementation of the SRD collision operator is shown below.</p>
<div class="table-wrapper colwidths-given docutils container">
<table class="docutils align-center">
<colgroup>
<col style="width: 33.3%" />
<col style="width: 33.3%" />
<col style="width: 33.3%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><a class="reference internal image-reference" href="../_images/SRD1.png"><img alt="../_images/SRD1.png" class="align-center" src="../_images/SRD1.png" style="width: 95%;" /></a>
</td>
<td><a class="reference internal image-reference" href="../_images/SRD2.png"><img alt="../_images/SRD2.png" class="align-center" src="../_images/SRD2.png" style="width: 95%;" /></a>
</td>
<td><a class="reference internal image-reference" href="../_images/SRD3.png"><img alt="../_images/SRD3.png" class="align-center" src="../_images/SRD3.png" style="width: 95%;" /></a>
</td>
</tr>
<tr class="row-even"><td><p><strong>(a)</strong> Bin MPCD particles into cells.</p></td>
<td><p><strong>(b)</strong> Calculate the center of mass velocity <span class="math notranslate nohighlight">\(\vec{v}^\mathrm{cm}\)</span> of the cell.</p></td>
<td><p><strong>(c)</strong> For each MPCD particle, calculate the difference from <span class="math notranslate nohighlight">\(\vec{v}^\mathrm{cm}\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><a class="reference internal image-reference" href="../_images/SRD4.png"><img alt="../_images/SRD4.png" class="align-center" src="../_images/SRD4.png" style="width: 95%;" /></a>
</td>
<td><a class="reference internal image-reference" href="../_images/SRD5.png"><img alt="../_images/SRD5.png" class="align-center" src="../_images/SRD5.png" style="width: 95%;" /></a>
</td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>(d)</strong> For each MPCD particle, generate a random unit vector <span class="math notranslate nohighlight">\(\hat{n}^\mathrm{ran}\)</span>.</p></td>
<td><p><strong>(e)</strong> Rotate each difference about <span class="math notranslate nohighlight">\(\hat{n}^\mathrm{ran}\)</span> by <span class="math notranslate nohighlight">\(\theta\)</span>.</p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>The version of SRD in which <span class="math notranslate nohighlight">\(\hat{n}\)</span> is chosen from the unit sphere is implemented with a keycode of <code class="docutils literal notranslate"><span class="pre">0</span></code>.
To use it, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;collOp&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span>
</pre></div>
</div>
<p>The angle must be set <strong>outside</strong> the “species” array:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;rotAng&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">1.570796</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default is <span class="math notranslate nohighlight">\(\pi/2\)</span>.</p>
</div>
<section id="random-cartesian-axis-srd">
<h4>Random-Cartesian-axis SRD<a class="headerlink" href="#random-cartesian-axis-srd" title="Permalink to this heading">#</a></h4>
<p>To reproduce in bulk a fluid with the correct hydrodynamic properties, it is sufficient to choose the axis of rotation <span class="math notranslate nohighlight">\(\vec{\hat{n}}\)</span> randomly from the cartesian axes, <span class="math notranslate nohighlight">\(\vec{\hat{n}} \in \left\{ [1, 0, 0], [0, 1, 0] , [0, 0, 1] \right\}\)</span>, which increases the efficiency of the algorithm.</p>
<p>This version of SRD is implemented with a keycode of <code class="docutils literal notranslate"><span class="pre">1</span></code>.
To use it add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;collOp&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
</section>
<section id="thermostatting-srd">
<h4>Thermostatting SRD<a class="headerlink" href="#thermostatting-srd" title="Permalink to this heading">#</a></h4>
<p>While SRD is sufficient for many applications, it is not thermostatted.
To ensure a constant temeprature an <a class="reference internal" href="#thermostats"><span class="std std-ref">external thermostat</span></a> must be applied or a thermostatted collision operator, such as <a class="reference internal" href="#andersen"><span class="std std-ref">Andersen</span></a> or <a class="reference internal" href="#langevin"><span class="std std-ref">Langevin</span></a>-MPCD, should be used.</p>
</section>
</section>
<section id="andersen-mpcd">
<span id="andersen"></span><h3>Andersen MPCD<a class="headerlink" href="#andersen-mpcd" title="Permalink to this heading">#</a></h3>
<p>Following other mesoscale simulation techniques, such as DPD, where a thermostat is included intrinsically as part of the simulation technique, thermostats have been incoroporated into MPCD collision operators.</p>
<p>The primary thermostatted collision operator in this simulator is the Andersen-thermostatted collision operator <a class="reference internal" href="../References/References.html#noguchi2007" id="id7"><span>[Noguchi2007]</span></a>, defined as</p>
<div class="math-wrapper docutils container" id="eq-andersenop">
<span id="equation-eq-andersenop"></span><div class="math notranslate nohighlight" id="eq-andersenop">
<span id="equation-eq-andersenop"></span><span class="eqno">(3)<a class="headerlink" href="#eq-andersenop" title="Permalink to this equation">#</a></span>\[\vec{\Xi}^\mathrm{A}(t) = \vec{\xi}_i - \left\langle \vec{\xi}_j \right\rangle_c ,\]</div>
</div>
<p>in which each component of <span class="math notranslate nohighlight">\(\vec{\xi}_i\)</span> is randomly generated from a Gaussian distribution with variance <span class="math notranslate nohighlight">\(\sqrt{k_B T/ m}\)</span> and <span class="math notranslate nohighlight">\(\left\langle \vec{\xi}_j \right\rangle_c = \left(\sum_j^{N_C} m_j \vec{\xi}_j\right)/\left(\sum_j^{N_C} m_j\right)\)</span>.</p>
<p>The final term in <a class="reference internal" href="#eq-andersenop"><span class="std std-ref">the Andersen collision operator</span></a> is referred to as the residual, and denoted <span class="math notranslate nohighlight">\(\langle \vec{\xi}_j \rangle_{c}\)</span>.
Each fluid particle in a given cell is assigned a new, randomly chosen velocity during each collision.
However, the presence of the residual means that each particle’s velocity is a new randomly assigned value, minus the mass weighted velocity of all the new random values for that cell. This ensures that the center of mass velocity of each cell does not change during collision, ensuring momentum conservation.</p>
<div class="table-wrapper colwidths-given docutils container">
<table class="docutils align-center">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><a class="reference internal image-reference" href="../_images/Andersen1.png"><img alt="../_images/Andersen1.png" class="align-center" src="../_images/Andersen1.png" style="width: 95%;" /></a>
</td>
<td><a class="reference internal image-reference" href="../_images/Andersen2.png"><img alt="../_images/Andersen2.png" class="align-center" src="../_images/Andersen2.png" style="width: 95%;" /></a>
</td>
</tr>
<tr class="row-even"><td><p><strong>(a)</strong> Bin MPCD particles into cells.</p></td>
<td><p><strong>(b)</strong> Calculate the center of mass velocity <span class="math notranslate nohighlight">\(\vec{v}^\mathrm{cm}\)</span> of the cell.</p></td>
</tr>
<tr class="row-odd"><td><a class="reference internal image-reference" href="../_images/Andersen3.png"><img alt="../_images/Andersen3.png" class="align-center" src="../_images/Andersen3.png" style="width: 95%;" /></a>
</td>
<td><a class="reference internal image-reference" href="../_images/Andersen4.png"><img alt="../_images/Andersen4.png" class="align-center" src="../_images/Andersen4.png" style="width: 95%;" /></a>
</td>
</tr>
<tr class="row-even"><td><p><strong>(c)</strong> For each MPCD particle, generate a random velocity that sums to <span class="math notranslate nohighlight">\(\vec{v}^\mathrm{cm}\)</span>.</p></td>
<td><p><strong>(d)</strong> Apply to each MPCD particle.</p></td>
</tr>
</tbody>
</table>
</div>
<p>The Andersen-thermostatted collision operator is implemented with a keycode of <code class="docutils literal notranslate"><span class="pre">2</span></code>.
To use it, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;collOp&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Andersen-thermostatted collision operator above is the default in NIAMH-MPCD.</p>
</div>
<section id="conserving-angular-momentum">
<span id="angmom"></span><h4>Conserving angular momentum<a class="headerlink" href="#conserving-angular-momentum" title="Permalink to this heading">#</a></h4>
<p>The <a class="reference internal" href="#eq-andersenop"><span class="std std-ref">the basic Andersen collision operator</span></a> conserves mass and translational momentum, but not angular momentum (or energy, as it is thermostatted).
In many advecting situations angular momentum does not play an essential role and so this fact is inconsequential <a class="reference internal" href="../References/References.html#gotze2007" id="id8"><span>[Götze2007]</span></a> <a class="reference internal" href="../References/References.html#gotze2011" id="id9"><span>[Götze2011]</span></a> <a class="reference internal" href="../References/References.html#babu2012" id="id10"><span>[Babu2012]</span></a>.</p>
<p>However, the Andersen collision operator can be extended to do so <a class="reference internal" href="../References/References.html#noguchi2007" id="id11"><span>[Noguchi2007]</span></a>. The basic Andersen collision operator introduces a small change in angular momentum relative to the centre of mass position during the collision event position at every timestep, denoted <span class="math notranslate nohighlight">\(\delta \vec{L}\)</span>.
This can be cancelled out by applying a small counter-rotation to each particle, such that the total angular momentum change is zero.
If the particles in the cell have a given intertia tensor <span class="math notranslate nohighlight">\(I\)</span> about the center of mass, then the required counter-rotation required is <span class="math notranslate nohighlight">\(\vec \omega = I^{-1} \cdot \delta \vec{L}\)</span>.</p>
<p>This correction is done by adding an extra term to the Andersen collision operator that performs this counter-rotation</p>
<div class="math-wrapper docutils container" id="eq-andersenopangular">
<span id="equation-eq-andersenopangular"></span><div class="math notranslate nohighlight" id="eq-andersenopangular">
<span id="equation-eq-andersenopangular"></span><span class="eqno">(4)<a class="headerlink" href="#eq-andersenopangular" title="Permalink to this equation">#</a></span>\[\vec{\Xi}^\mathrm{A}(t) =
\vec{\xi}_i -
\langle \vec{\xi}_j \rangle_{N_C} +
\left[
    I^{-1} \cdot \left(
        \sum_j^{N_C} m_j \left\lbrace
            \vec{x}'_j \times (\vec{v}_j - \vec{\xi}_j)
        \right\rbrace
    \right)
\right] \times \vec{x}'_j,\]</div>
</div>
<p>in which <span class="math notranslate nohighlight">\(\vec{x}'_j\)</span> denotes the position of the particle with respect to the cell’s cooridnate center of mass.</p>
<p>The angular-conserving Andersen-thermostatted collision operator is implemented with a keycode of <code class="docutils literal notranslate"><span class="pre">3</span></code>.
To use it, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;collOp&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The angular-conserving Andersen-thermostatted collision operator is the basis used for the <a class="reference internal" href="#nematicmpcd"><span class="std std-ref">Nematic MPCD</span></a> algorithm.</p>
</div>
</section>
</section>
<section id="langevin-mpcd">
<span id="langevin"></span><h3>Langevin MPCD<a class="headerlink" href="#langevin-mpcd" title="Permalink to this heading">#</a></h3>
<p>A Langevin thermostat can also be used to create an MPCD algorithm <a class="reference internal" href="../References/References.html#noguchi2007" id="id12"><span>[Noguchi2007]</span></a>.
A thermodynamic reservoir is assumed to enact two effects on the fluid particles:</p>
<blockquote>
<div><ul class="simple">
<li><p>A resistive, viscous force that opposes the motion of the fluid particles, characterized by a friction constant <span class="math notranslate nohighlight">\(\gamma\)</span>.</p></li>
<li><p>Random kicks due to thermal white noise <span class="math notranslate nohighlight">\(\vec{\xi}\)</span>.</p></li>
</ul>
</div></blockquote>
<p>The Langevin force on particle <span class="math notranslate nohighlight">\(i\)</span> is thus <span class="math notranslate nohighlight">\(\vec{f} = -\gamma \vec{v}_i + \sqrt{\gamma}\vec{\xi}_i\)</span>.
The Langevin thermostat has an additional parameter (<span class="math notranslate nohighlight">\(\gamma\)</span>) compared to the <a class="reference internal" href="#andersen"><span class="std std-ref">Andersen-thermostatted version</span></a>.</p>
<p>When the Langevin thermostat is applied to MPCD, the background force on the fluid particles produces the Langevin-thermostatted MPCD collision operator</p>
<div class="math-wrapper docutils container" id="eq-langevinop">
<span id="equation-eq-langevinop"></span><div class="math notranslate nohighlight" id="eq-langevinop">
<span id="equation-eq-langevinop"></span><span class="eqno">(5)<a class="headerlink" href="#eq-langevinop" title="Permalink to this equation">#</a></span>\[\vec{\Xi}^\mathrm{L} = a\left(\vec{v}_i - \vec{v}_{c}\right) - b\left( \vec{\xi}_i - \sum_j^{N_c} \frac{\vec{\xi}_j}{N_c} \right) ,\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(a = \left(2m-\gamma\delta t\right) / \left(2m+\gamma\delta t\right)\)</span> and <span class="math notranslate nohighlight">\(b = 2\sqrt{\gamma \delta t} / \left(2m+\gamma \delta t \right)\)</span>.</p>
<p>To use Langevin-thermostatted MPCD, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;collOp&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span>
</pre></div>
</div>
<p>A Langevin drag coefficient should also be specified <strong>outside</strong> the “species” array:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;fricCoef&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">1.0</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The default value for <cite>“fricCoef”</cite> is 1.</p></li>
<li><p>Currently, all species have the same <span class="math notranslate nohighlight">\(\gamma\)</span>.</p></li>
</ul>
</div>
</section>
<section id="nematic-mpcd">
<span id="nematicmpcd"></span><h3>Nematic MPCD<a class="headerlink" href="#nematic-mpcd" title="Permalink to this heading">#</a></h3>
<p>The collision operators are applied to the linear momentum.
However, collision operators can be applied to particle orientation in nematic-MPCD <a class="reference internal" href="../References/References.html#shendruk2015" id="id13"><span>[Shendruk2015]</span></a>.
Each MPCD particle is assigned an <a class="reference internal" href="#orientationparticles"><span class="std std-ref">orientation</span></a> <span class="math notranslate nohighlight">\(\vec{u}_i\)</span>, which is cell-averaged into a <a class="reference internal" href="#nematicincell"><span class="std std-ref">tensor order parameter</span></a> <span class="math notranslate nohighlight">\(\boldsymbol{Q}_c\)</span>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Because the nematic MPCD algorithm balances torques, the momentum collision operator <strong>must</strong> be set to <a class="reference internal" href="#angmom"><span class="std std-ref">angular-conserving Andersen-thermostatted MPCD</span></a> in your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;collOp&quot;</span><span class="p">:</span><span class="w">    </span><span class="mi">3</span>
</pre></div>
</div>
</div>
<section id="nematogen-collision-operator">
<span id="nemcollop"></span><h4>Nematogen collision operator<a class="headerlink" href="#nematogen-collision-operator" title="Permalink to this heading">#</a></h4>
<p>Similar to the <a class="reference internal" href="#andersen"><span class="std std-ref">Andersen MPCD collision operator</span></a>, the time evolution of the particles’ orientation is carried out through a neaer-equilibrium collision event <a class="reference internal" href="../References/References.html#shendruk2015" id="id14"><span>[Shendruk2015]</span></a></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\vec{u}_i(t+\delta t) = \Psi_c(U,\boldsymbol{Q}_{c}(t)),\]</div>
</div>
<p>in which <span class="math notranslate nohighlight">\(U\)</span> denotes a globally specified interaction constant that represents the inter-molecular interactions, and as such, sets the energy scale that dictates the time evolution of the particles’ orientation.
Taking inspiration from <a class="reference internal" href="#andersen"><span class="std std-ref">Andersen-thermostatted MPCD</span></a>, the orientation of particles in a cell <span class="math notranslate nohighlight">\(c\)</span> are drawn from the local equilibrium distribution predicted from Maier-Saupe mean-field theory.
More specifically, the algorithm assumes that the local distribution for the orientation fields is well described by the Maier-Saupe self-consistent mean-field theory</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[f_\text{ori} = g \exp(-\beta W_\text{MF}(U,S_c,u_n)),\]</div>
</div>
<p>in which <span class="math notranslate nohighlight">\(u_n \equiv \vec{u}_i\cdot\vec{n}_c\)</span>, <span class="math notranslate nohighlight">\(\beta=1/k_B T\)</span> and</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[W_{\text{MF}} = -U S_c u_n^2 + \frac{U}{d}(S_c-1) = -U \left( \vec{u}_i\cdot \boldsymbol{Q}_{c} \cdot \vec{u}_i \right) + \text{const}\]</div>
</div>
<p>is the mean field interaction potential. Since the second term in this potential is independent of <span class="math notranslate nohighlight">\(u_n\)</span>, the distribution is controlled by the competition between the thermal energy <span class="math notranslate nohighlight">\(\beta^{-1}\)</span> and the interaction energy <span class="math notranslate nohighlight">\(S_c U\)</span>, as quantified by the scaled energy <span class="math notranslate nohighlight">\(\beta U S_c\)</span>.
When the scaled energy is small, the distribution is flat, and all values of <span class="math notranslate nohighlight">\(n_c\)</span> are equally likely — i.e., isotropic. If, instead, the scaled energy is large, the distribution becomes sharply centered around <span class="math notranslate nohighlight">\(\vec{n}_c\)</span>.</p>
<p>The nematic collision operator works by drawing random orientations from the equilibrium orientation distribution <span class="math notranslate nohighlight">\(f_\mathrm{ori}\)</span>, leading to values centered around the local director <span class="math notranslate nohighlight">\(\vec{n}_c\)</span>.
The orientation is not a conserved quantity and so can fluctuate about the director, but, for a high enough cell population, the changes in individual particle orientations, <span class="math notranslate nohighlight">\(\delta\vec{u}_{\text{col},i} = \vec{u}_i(t+\delta t)-\vec{u}_i(t)\)</span>, do not alter the cell’s director <span class="math notranslate nohighlight">\(\vec{n}_c(t)\)</span>.</p>
<section id="mean-field-potential">
<span id="meanfieldpotential"></span><h5>Mean field potential<a class="headerlink" href="#mean-field-potential" title="Permalink to this heading">#</a></h5>
<p>To set the mean field potential <span class="math notranslate nohighlight">\(U\)</span>, add the following to your <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array in the input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;mfpot&quot;</span><span class="p">:</span><span class="w">    </span><span class="mf">10.0</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The default value is 10.</p></li>
<li><p>In 3D, the first-order isotropic-to-nematic phase transition happens at <span class="math notranslate nohighlight">\(U=4.20 \pm 0.05\)</span>. In 2D, the KT transition happens at <span class="math notranslate nohighlight">\(U=4.1 \pm 0.1\)</span>.</p></li>
</ul>
</div>
</section>
<section id="isotropic-nematic-transition">
<h5>Isotropic-nematic transition<a class="headerlink" href="#isotropic-nematic-transition" title="Permalink to this heading">#</a></h5>
<p>As mentioned above, increasing <span class="math notranslate nohighlight">\(\beta U\)</span> changes the orientation distribution from flat to highly peaked.
Operationally, this means that a system with a small <span class="math notranslate nohighlight">\(\beta U\)</span> will exist in an isotropic fluid state with a global scalar order parameter <span class="math notranslate nohighlight">\(S\)</span> close to zero.
On the contrary, setting a large value of <span class="math notranslate nohighlight">\(\beta U\)</span> will lead to a nematic order.
Even though the algorithm assumes a near-equilibrium Maier-Saupe distribution for the orientation, it does so at the local cell level.
This means that in general the scalar order parameter and the director are spatially varying variables, which allows the system to exist with local nematic order between the two regimes discussed above.
In MPCD units, for a mean population of 20 particles per MPCD cell, in 2D <span class="math notranslate nohighlight">\(U=5\)</span> sets the threshold for nematic order. By default, the code runs at <span class="math notranslate nohighlight">\(U=10\)</span>.</p>
</section>
<section id="frank-elastic-coefficients">
<h5>Frank elastic coefficients<a class="headerlink" href="#frank-elastic-coefficients" title="Permalink to this heading">#</a></h5>
<p>Spatial distortions of the nematic director $vec{n}$ have an energetic cost.
This cost is given by the following free energy density</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[f = \frac{1}{2}K_{\text{splay}}(\vec{\nabla}\cdot\vec{n})^2
+\frac{1}{2}K_{\text{twist}}(\vec{n}\cdot\vec{\nabla}\times\vec{n})^2
+\frac{1}{2}K_{\text{bend}}(\vec{n}\times(\vec{\nabla}\times\vec{n}))^2,\]</div>
</div>
<p>in which <span class="math notranslate nohighlight">\(K_{\text{splay}}\)</span>, <span class="math notranslate nohighlight">\(K_{\text{twist}}\)</span> and <span class="math notranslate nohighlight">\(K_{\text{bend}}\)</span> are three coeffiecients quantifying the energetic cost of the three different possible distortions: splay, twist and bend respectively.  This coefficients are collectively known as Frank elastic coefficients. Although in principle there are differences between the three coefficients, in the regime of small rods (compared to interaction lengths) under which nematic MPCD operates, these are negligible, and thus the algorithm presents isotropic elasticity, i.e. a single-constant approximation of <span class="math notranslate nohighlight">\(K=K_{\text{splay}}=K_{\text{twist}}=K_{\text{bend}}\)</span>, which makes the deformation free energy density simply <span class="math notranslate nohighlight">\(f = \frac{1}{2}K(\vec{\nabla}\cdot\vec{n})^2\)</span>.</p>
<p>In the nematic-MPCD algorithm, <span class="math notranslate nohighlight">\(\beta U\)</span> controls the interaction between nematogens and so also sets the Frank coefficients of order <span class="math notranslate nohighlight">\(K \sim U/a\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For number density <span class="math notranslate nohighlight">\(\left\langle n_c \right\rangle =20\)</span>,  <span class="math notranslate nohighlight">\(K = (113 \pm 6)U\)</span>.</p>
</div>
</section>
</section>
<section id="two-way-couping-between-flow-and-orientation">
<span id="backflow"></span><h4>Two-way couping between flow and orientation<a class="headerlink" href="#two-way-couping-between-flow-and-orientation" title="Permalink to this heading">#</a></h4>
<p>While the orientation collision operator deals with the alignment of the nematic MPCD particles, to correctly reproduce nematohydrodynamics it is equally important to incorporate the coupling between the particle’s orientation and the fluid flow.
This coupling comes in two ways:</p>
<ol class="arabic simple">
<li><p>Flow rotates the particles’ orientation</p></li>
<li><p>Particle motion can produce backflow.</p></li>
</ol>
<p>To address this, the nematic MPCD algorithm treats nematogens as if they were rotating through their own flow, envisioning them as dilute rods in a viscous/non-inertial fluid <a class="reference internal" href="../References/References.html#shendruk2015" id="id15"><span>[Shendruk2015]</span></a>, akin to how the <a class="reference internal" href="#langevin"><span class="std std-ref">Langevin collision operator</span></a> includes a drag.
With this assumption, it follows that the nematic MPCD particles are subjected to three different sources of torque</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\vec{\Gamma}_{\text{net},i} = \vec{\Gamma}_{\text{HI},i}+ \vec{\Gamma}_{\text{col},i}+\vec{\Gamma}_{\text{ext},i}.\]</div>
</div>
<p>These are:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\vec{\Gamma}_{\text{HI},i}\)</span>: Hydrodynamic torques due to the vorticity of the flow field and its shear rate.</p></li>
<li><p><span class="math notranslate nohighlight">\(\vec{\Gamma}_{\text{col},i} = \gamma_\text{R}\vec{u}_i\times \dot{\vec{u}}_{\text{col},i}\)</span>: The thermal torque caused by the orientational collision operator, where <span class="math notranslate nohighlight">\(\dot{\vec{u}}_{\text{col},i} =\delta\vec{u}_{\text{col},i}/\delta t\)</span> denotes the thermally induced rotation rate and <span class="math notranslate nohighlight">\(\gamma_\text{R}\)</span> is the rotational friction coefficient.</p></li>
<li><p><span class="math notranslate nohighlight">\(\vec{\Gamma}_{\text{ext},i}\)</span>, external torques, caused, for example, by electric fields, magnetic fields or <a class="reference internal" href="#chapterbc"><span class="std std-ref">boundaries</span></a>.</p></li>
</ol>
<p>Because this algorithm assumes a viscous overdamped fluid, these torques must balance each other, resulting in a vanishing net torque:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\vec{\Gamma}_{\text{net},i} = 0.\]</div>
</div>
<p>Solving this equation for the rotation rate of an MPCD particle, <span class="math notranslate nohighlight">\(\dot{\vec{u}}_i\)</span>, shows that <span class="math notranslate nohighlight">\(\dot{\vec{u}}_i = \dot{\vec{u}}_{\text{HI},i}+\dot{\vec{u}}_{\text{col},i}\)</span>, in which
<span class="math notranslate nohighlight">\(\dot{\vec{u}}_{\text{col},i}\)</span> is the thermally induced rotation rate and <span class="math notranslate nohighlight">\(\dot{\vec{u}}_{\text{HI},i}\)</span> is the rotation rate induced by the vorticity and shear rate of the fluid.
In the particular case of a thin rod, which is assumed by the algorithm, the latter is described by Jeffery’s equation</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{\delta \vec{u}_{\text{HI},i}}{\delta t} = \chi_{\text{HI}} \left[\vec{u}_i\cdot\vec{w}+\lambda (\vec{u}_i\cdot \vec{D}-\vec{u}_i(\vec{u}_i\vec{u}_i:\vec{\omega}))\right],\]</div>
</div>
<p>in which <span class="math notranslate nohighlight">\(\chi_{HI}\)</span> is an heuristic shear coupling coefficient that sets the alignment relaxation time, <span class="math notranslate nohighlight">\(\lambda\)</span> is the bare tumbling parameter, while <span class="math notranslate nohighlight">\(\vec{D}\)</span> and <span class="math notranslate nohighlight">\(\vec{\omega}\)</span> respectively represent the shear rate and vorticity from the <a class="reference internal" href="#velgrad"><span class="std std-ref">velocity gradient tensor</span></a>.</p>
<p>In turn, the nematic MPCD algorithm included the backflow induced by the nematogen in the fluid by modifiying the <a class="reference internal" href="#andersen"><span class="std std-ref">Andersen velocity collision operator</span></a> to include balancing angular impulses, i.e., equal in magnitude but opposite in direction, to those caused by the hydrodynamic torques on each nematogen <span class="math notranslate nohighlight">\(\vec{\Gamma}_{\text{HI},i} = -(\vec{\Gamma}_{\text{col},i}+\vec{\Gamma}_{\text{ext},i})\)</span>.
To counter this impulse with the hydrodynamic drag, this is then transferred to the linear momentum portion of the algorithm, thus modifying the Andersen MPCD collision operator to:</p>
<div class="math-wrapper docutils container" id="eq-nematiccollision">
<span id="equation-eq-nematiccollision"></span><div class="math notranslate nohighlight" id="eq-nematiccollision">
<span id="equation-eq-nematiccollision"></span><span class="eqno">(6)<a class="headerlink" href="#eq-nematiccollision" title="Permalink to this equation">#</a></span>\[\vec{\Xi}^N_{i,c} = \vec{\xi}_i - \langle \xi_j\rangle _{N_c} +\left(\vec{I}_c^{-1}\cdot\left[\delta \vec{L}_c-\sum_{i=1}^{N_c}\vec{\Gamma}_{\text{HI},i}\delta t\right]\right)\times \vec{r}_i'\]</div>
</div>
<p>Proceeding in this way ensures that the system’s total angular momentum is conserved. Furthermore, as setting <span class="math notranslate nohighlight">\(\gamma_\text{R}=0\)</span> kills the transfer or momentum for each particle, this also results in turning this coupling off.</p>
<section id="rotational-friction-coefficient">
<span id="rotationfriction"></span><h5>Rotational friction coefficient<a class="headerlink" href="#rotational-friction-coefficient" title="Permalink to this heading">#</a></h5>
<p>Nematic MPCD particles are assigned a rotational friction coefficient <span class="math notranslate nohighlight">\(\gamma_\text{R}\)</span> so that there is no angular acceleration between collision events (just as the <a class="reference internal" href="../Algorithm/Algorithm.html#streaming"><span class="std std-ref">isotropic MPCD algorithm does not include any translational acceleration</span></a>). The angular drift velocity <span class="math notranslate nohighlight">\({\omega} = d{\theta}/dt\)</span> in response to an external torque <span class="math notranslate nohighlight">\({\Gamma}\)</span> is s given by <span class="math notranslate nohighlight">\({\omega} = {\Gamma}/f_r\)</span> where <span class="math notranslate nohighlight">\(f_r\)</span> is the rotational drag coefficient.</p>
<p>To set the rotational friction coefficient, add the following to your <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array in the input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;rfc&quot;</span><span class="p">:</span><span class="w">    </span><span class="mf">0.01</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0.01.</p>
</div>
</section>
<section id="shear-susceptibility">
<span id="shearsus"></span><h5>Shear susceptibility<a class="headerlink" href="#shear-susceptibility" title="Permalink to this heading">#</a></h5>
<p>The nematic MPCD algorithm includes a susceptibility of the director to shear <span class="math notranslate nohighlight">\(\chi_\text{HI}\)</span>. Theoretically, it is always 1 but practically a heuristic shear coupling coefficient should exit, that tunes the alignment relaxation time relative to <span class="math notranslate nohighlight">\({\delta} t\)</span>. When the shear coupling coefficient is set to <span class="math notranslate nohighlight">\(\chi_\text{HI}=0\)</span> there is no coupling of the director to the velocity field.</p>
<p>To set the shear susceptibility, add the following to your <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array in the input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;shearSusc&quot;</span><span class="p">:</span><span class="w">    </span><span class="mf">0.5</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0.5.</p>
</div>
</section>
<section id="tumbling-parameter">
<span id="tumbling"></span><h5>Tumbling parameter<a class="headerlink" href="#tumbling-parameter" title="Permalink to this heading">#</a></h5>
<p>Coupling between the director and fluid flow is crucial for reproducing nematohydrodynamics since flows can rotate the nematogens just as it can rotate any rodlike, or elongated object. The director profile is not only rotated by the flow, but can also align when subject to a shear. The orientational response of individual particles obeys the Jeffery equation and the bare tumbling parameter <span class="math notranslate nohighlight">\(\lambda\)</span> specifiec how the nematogens respond to a shear. If <span class="math notranslate nohighlight">\(\lambda \geq 1\)</span>, the director field aligns with the flow—such LCs are known as “flow-aligning” . If <span class="math notranslate nohighlight">\(\lambda &lt; 1\)</span>, the director field rotates in the flow continuously—such LCs are known as “flow-tumbling”.</p>
<p>To set the bare tumbling parameter, add the following to your <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array in the input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;tumble&quot;</span><span class="p">:</span><span class="w">    </span><span class="mf">2.0</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 2.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <em>bare</em> tumbling parameter <span class="math notranslate nohighlight">\(\lambda\)</span> in the Jeffery’s equation only applies in the limit of a dilute suspension of nematogens. Away from that limit, Jeffery’s equation can still be used but, because of nematogen-nematogen interactions with a renormalized tumbling parameter <a class="reference internal" href="../References/References.html#archer1995" id="id16"><span>[Archer1995]</span></a></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\lambda' = \left(\frac{15\,S+84\,S_4+42}{105\, S}\right) \lambda,\]</div>
</div>
<p>in which <span class="math notranslate nohighlight">\(S_4\)</span> is the fourth moment of the Marie-Soupe distribution. In the nematic MPCD algorithm, the input is the bare tumbling parameter <span class="math notranslate nohighlight">\(\lambda\)</span>. As such, care must be paid in that what determines the behaviour of the nematogens is <span class="math notranslate nohighlight">\(\lambda'\)</span>, not <span class="math notranslate nohighlight">\(\lambda\)</span>. For <span class="math notranslate nohighlight">\(\lambda'&lt;1\)</span>, the nematogens tumble, i.e., continuously revolve. For <span class="math notranslate nohighlight">\(|\lambda'|&gt;1\)</span> the nematogens experience shear align to the flow.</p>
</div>
</section>
</section>
</section>
<section id="active-nematic-mpcd">
<span id="activenematic"></span><h3>Active-nematic MPCD<a class="headerlink" href="#active-nematic-mpcd" title="Permalink to this heading">#</a></h3>
<p>Active nematics are continually driven away from equilibrium at the microscopic scale. In wet systems, they inject energy while conserving momentum. To do so, active stress is introduced to fluid in the form of a force dipole density acting on MPCD nematogens. The active nematic MPCD algorithm achieves this at the level of MPCD cells by adding an active term to the nematic velocity collision operator <a class="reference internal" href="../References/References.html#kozhukhov2022" id="id17"><span>[Kozhukhov2022]</span></a>.</p>
<p>Active-nematic MPCD introduces a local force dipole along the <a class="reference internal" href="#nematicincell"><span class="std std-ref">cell director</span></a> <span class="math notranslate nohighlight">\(\vec{n}_c\)</span>.
To induce force dipoles, a plane is placed at the cell’s <a class="reference internal" href="#cmofcell"><span class="std std-ref">center of mass</span></a> with its normal vector aligned to the cell’s director, <span class="math notranslate nohighlight">\(\vec{n}_c\)</span>.
Particles forward of the plane get a kick forward, and particles backward of the plane get a kick backward.</p>
<div class="table-wrapper colwidths-given docutils container">
<table class="docutils align-center">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><a class="reference internal image-reference" href="../_images/ActivityDiagram-0.png"><img alt="../_images/ActivityDiagram-0.png" class="align-center" src="../_images/ActivityDiagram-0.png" style="width: 95%;" /></a>
</td>
<td><a class="reference internal image-reference" href="../_images/ActivityDiagram-1.png"><img alt="../_images/ActivityDiagram-1.png" class="align-center" src="../_images/ActivityDiagram-1.png" style="width: 95%;" /></a>
</td>
</tr>
<tr class="row-even"><td><p><strong>(a)</strong> Bin MPCD particles into cells.</p></td>
<td><p><strong>(b)</strong> Place a plane normal to the cell director at the cell center of mass.</p></td>
</tr>
<tr class="row-odd"><td><a class="reference internal image-reference" href="../_images/ActivityDiagram-2.png"><img alt="../_images/ActivityDiagram-2.png" class="align-center" src="../_images/ActivityDiagram-2.png" style="width: 95%;" /></a>
</td>
<td><a class="reference internal image-reference" href="../_images/ActivityDiagram-3.png"><img alt="../_images/ActivityDiagram-3.png" class="align-center" src="../_images/ActivityDiagram-3.png" style="width: 95%;" /></a>
</td>
</tr>
<tr class="row-even"><td><p><strong>(c)</strong> For each MPCD particle forward of the plane, give a kick forward, and vica-versa.</p></td>
<td><p><strong>(d)</strong> Apply kicks to the post-nematic velocity collision.</p></td>
</tr>
</tbody>
</table>
</div>
<p>This is sufficient to reproduce a local force dipole within each cell.
Furthermore, the positioning of the plane ensures that this operation conserves linear momentum, despite the local injection of energy. This collision operation is expressed as:</p>
<div class="math-wrapper docutils container" id="eq-activenematiccollision">
<span id="equation-eq-activenematiccollision"></span><div class="math notranslate nohighlight" id="eq-activenematiccollision">
<span id="equation-eq-activenematiccollision"></span><span class="eqno">(7)<a class="headerlink" href="#eq-activenematiccollision" title="Permalink to this equation">#</a></span>\[\vec{\Xi}_i^\mathrm{AN}(t) =
\vec{\Xi}_i^\mathrm{N}(t) +
\alpha_c \delta t \left(
    \frac{\kappa_i}{m_i} - \langle \frac{\kappa_j}{m_j} \rangle_C
\right)\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\kappa_i=\pm1\)</span> represent whether a particle is forward or backward of the plane <a class="reference internal" href="../References/References.html#kozhukhov2022" id="id18"><span>[Kozhukhov2022]</span></a>.</p>
<p>The active contribution is then composed of two terms:</p>
<ol class="arabic simple">
<li><p>The first term, <span class="math notranslate nohighlight">\(\alpha_c\delta_t\left(\frac{\kappa_i}{m_i}\right)\vec{n}\)</span>, provides individual impulses (per unit mass) to each particle and corresponds to the active forcing.</p></li>
<li><p>The second term, <span class="math notranslate nohighlight">\(-\alpha_c\delta_t\left\langle\frac{\kappa_j}{m_j}\right\rangle_c\vec{n}\)</span>, ensures conservation of momentum inside each cell by removing any residual impulse.</p></li>
</ol>
<p>The strength of the active dipoles and the active stress is set by the cell’s activity <span class="math notranslate nohighlight">\(\alpha_c\)</span>, which is determined by the activity <span class="math notranslate nohighlight">\(\alpha_i\)</span> of the particles in that cell. Positive and negative values correspond to extensile or contractile force dipoles, respectively <a class="reference internal" href="../References/References.html#kozhukhov2022" id="id19"><span>[Kozhukhov2022]</span></a>.  To set the <strong>fluid-species activity</strong>, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file  <strong>inside</strong> the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array for each fluid-species:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;act&quot;</span><span class="p">:</span><span class="w">   </span><span class="mf">0.05</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The default value is 0.05.</p></li>
<li><p>The turbulence regime for extensile and contractile are not the same.</p></li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Because the active-nematic MPCD algorithm builds on nematic MPCD, the <a class="reference internal" href="#nematicon"><span class="std std-ref">liquid crystal flag</span></a> must be set to <strong>on</strong> in your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;lc&quot;</span><span class="p">:</span><span class="w">        </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The active turbulence regime has been found within the regime <span class="math notranslate nohighlight">\(0.03\leq\zeta\leq0.08\)</span>.
For smaller values, the injected energy is absorbed by the thermostat, while the density varies substantially for larger values.</p>
</div>
<section id="variation-on-the-strength-of-activity">
<h4>Variation on the strength of activity<a class="headerlink" href="#variation-on-the-strength-of-activity" title="Permalink to this heading">#</a></h4>
<p>In the algorithm, <span class="math notranslate nohighlight">\(\alpha_c\)</span> can be chosen in four different ways, encoded as four different collision operators:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#pcact"><span class="std std-ref">Particle-carried activity</span></a> — <code class="docutils literal notranslate"><span class="pre">&quot;collOp&quot;:</span> <span class="pre">16</span></code></p></li>
<li><p><a class="reference internal" href="#ccact"><span class="std std-ref">Cell-carried activity</span></a> — <code class="docutils literal notranslate"><span class="pre">&quot;collOp&quot;:</span> <span class="pre">17</span></code></p></li>
<li><p><a class="reference internal" href="#modact"><span class="std std-ref">Modulated cell-carried activity</span></a> — <code class="docutils literal notranslate"><span class="pre">&quot;collOp&quot;:</span> <span class="pre">20</span></code></p></li>
<li><p><a class="reference internal" href="#modact"><span class="std std-ref">Modulated particle-carried activity</span></a> — <code class="docutils literal notranslate"><span class="pre">&quot;collOp&quot;:</span> <span class="pre">21</span></code></p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For optimal density behaviour, we recommend using
modulated particle-carried activity (<code class="docutils literal notranslate"><span class="pre">&quot;collOp&quot;:</span> <span class="pre">21</span></code>) <a class="reference internal" href="../References/References.html#kozhukhov2024" id="id20"><span>[Kozhukhov2024]</span></a>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note: You can use <span class="math notranslate nohighlight">\(\alpha_i &lt; 0\)</span> to simulate contractile nematics, but only in a limited regime.</p>
</div>
<section id="particle-carried-activity">
<span id="pcact"></span><h5>Particle-carried activity<a class="headerlink" href="#particle-carried-activity" title="Permalink to this heading">#</a></h5>
<p>In this version of the active nematic collision operator, the cell activity <span class="math notranslate nohighlight">\(\alpha_c\)</span> is the sum of the activities of all the particles inside the cell</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\alpha^P_c = \sum_{i=1}^{N_c}\alpha_i .\]</div>
</div>
<p>With this choice, the strength of the active impulses provided by the collision operator increases with the population of the cell <a class="reference internal" href="../References/References.html#kozhukhov2022" id="id21"><span>[Kozhukhov2022]</span></a>.</p>
<p>This is implemented with a keycode of <code class="docutils literal notranslate"><span class="pre">16</span></code>, and can be used by adding the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file  <strong>inside</strong> the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array for each fluid-species:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;collOp&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">16</span>
</pre></div>
</div>
</section>
<section id="cell-carried-activity">
<span id="ccact"></span><h5>Cell-carried activity<a class="headerlink" href="#cell-carried-activity" title="Permalink to this heading">#</a></h5>
<p>The affect of the number of particles in a cell can be removed by defining the cell activity strength to be the mean activity of all particles inside the cell</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\alpha^C_c = \frac{1}{N_c}\sum_{i=1}^{N_c}\alpha_i .\]</div>
</div>
<p>In the particular case in which all particles have the same activity (for a example, a simulation with a single species), this makes the cell activity strength uniform and homogeneous <a class="reference internal" href="../References/References.html#kozhukhov2024" id="id22"><span>[Kozhukhov2024]</span></a>.</p>
<p>This is implemented with a keycode of <code class="docutils literal notranslate"><span class="pre">17</span></code>, and can be used by adding the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file <strong>inside</strong> the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array for each fluid-species:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;collOp&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">17</span>
</pre></div>
</div>
</section>
<section id="modulated-activity">
<span id="modact"></span><h5>Modulated activity<a class="headerlink" href="#modulated-activity" title="Permalink to this heading">#</a></h5>
<p>There is also the possibility to couple the cell activity strength to the cell population by supressing it at high densities <a class="reference internal" href="../References/References.html#kozhukhov2024" id="id23"><span>[Kozhukhov2024]</span></a>, which leads to two modulated collision operators. The modulation function, which takes the form of a sigmoid:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[S_C(N_C; \sigma_p, \sigma_w) = \frac{1}{2}\left(1-\tanh\left(\frac{N_c-\langle N_c\rangle (1+\sigma_P)}{\langle N_c\rangle \sigma_W}\right)\right),\]</div>
</div>
<p>which takes the local number of particles, <span class="math notranslate nohighlight">\(N_C\)</span> and returns a values in the range <span class="math notranslate nohighlight">\([0, 1]\)</span>.
It is controlled by two parameters:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\sigma_p\)</span> repesents where the modulation function is centred in units of mean density.</p></li>
<li><p><span class="math notranslate nohighlight">\(\sigma_w\)</span> represents how steep the modulation drop-off is in units of the mean density.</p></li>
</ul>
<div class="table-wrapper docutils container">
<table class="docutils align-center">
<tbody>
<tr class="row-odd"><td><a class="reference internal image-reference" href="../_images/ANModulationFn.png"><img alt="../_images/ANModulationFn.png" class="align-center" src="../_images/ANModulationFn.png" style="width: 95%;" /></a>
</td>
</tr>
<tr class="row-even"><td><p>A demonstration of the sigmoidal modulation function <span class="math notranslate nohighlight">\(\mathcal{S}_C(\rho_C; \sigma_p, \sigma_w)\)</span>.
Here, <span class="math notranslate nohighlight">\(\langle\rho_C\rangle=5\)</span> for illustration purposes, with <span class="math notranslate nohighlight">\(\sigma_p=1\)</span> and <span class="math notranslate nohighlight">\(\sigma_w=1\)</span>.</p></td>
</tr>
</tbody>
</table>
</div>
<p>The modulation parameters are configured with species-based parameters in your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file <strong>inside</strong> the <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array for each fluid-species:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;sigPos&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.4</span><span class="p">,</span>
<span class="nt">&quot;sigWidth&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.5</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The default value of both is 1</p></li>
<li><p>But the ideal <span class="math notranslate nohighlight">\({\sigma}_w\approx0.4\)</span></p></li>
<li><p>And the ideal <span class="math notranslate nohighlight">\({\sigma}_p\approx0.5\)</span> [Kozhukhov2024]</p></li>
</ul>
</div>
<p>This modulation function is then applied to each cells active force magnitude, giving two new formulations:</p>
<ul class="simple">
<li><p><strong>Modulated cell-carried</strong>: <span class="math notranslate nohighlight">\(\alpha_c^\mathrm{MC} = \mathcal{S}_C(\rho_C) \alpha_c^\mathrm{C}\)</span></p></li>
<li><p><strong>Sigmoidal-Sum</strong>: <span class="math notranslate nohighlight">\(\alpha_c^\mathrm{MP} = \mathcal{S}_C(\rho_C) \alpha_c^\mathrm{P}\)</span></p></li>
</ul>
<p>These are implemented with keycodes <code class="docutils literal notranslate"><span class="pre">20</span></code> and <code class="docutils literal notranslate"><span class="pre">21</span></code> respectively, and can be used by adding the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;collOp&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">20</span>
</pre></div>
</div>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;collOp&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">21</span>
</pre></div>
</div>
</section>
<section id="ratio-of-active-particles">
<span id="actratio"></span><h5>Ratio of active particles<a class="headerlink" href="#ratio-of-active-particles" title="Permalink to this heading">#</a></h5>
<p>Activity can be applied to a proportion of particles in the cell, the <strong>minimum</strong> of which is this parameter. To set it, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;minActRatio&quot;</span><span class="p">:</span><span class="w">    </span><span class="mf">0.0</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0.</p>
</div>
</section>
</section>
</section>
<section id="active-polar-mpcd">
<span id="apmpcd"></span><h3>Active-Polar MPCD<a class="headerlink" href="#active-polar-mpcd" title="Permalink to this heading">#</a></h3>
<p>The MPCD framework has also been extended to simulate dry polar active matter <a class="reference internal" href="../References/References.html#baziei2025" id="id24"><span>[Baziei2025]</span></a>. There are three active-polar MPCD algorithms.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When running active-polar MPCD, the <a class="reference internal" href="#nematicon"><span class="std std-ref">liquid crystal flag</span></a> must be set to <strong>off</strong> in your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;lc&quot;</span><span class="p">:</span><span class="w">        </span><span class="mi">0</span><span class="p">,</span>
</pre></div>
</div>
</div>
<section id="vicsek-mpcd">
<h4>Vicsek MPCD<a class="headerlink" href="#vicsek-mpcd" title="Permalink to this heading">#</a></h4>
<p>This collission operator is based on the Vicsek model of self-driven particles <a class="reference internal" href="../References/References.html#vicsek1995" id="id25"><span>[Vicsek1995]</span></a>. Key principles of the Vicsek model are:</p>
<ul class="simple">
<li><p><strong>Self-Propelled Particles</strong>: The fundamental units in the Vicsek Model are self-propelled particles that move at a constant speed and possess a heading direction, which can be influenced by their local neighbours.</p></li>
<li><p><strong>Local Interaction</strong>: Agents interact with their immediate neighbors within a defined radius. This matches well with the multi-particle collisions of MPCD.</p></li>
<li><p><strong>Noise</strong>: The model incorporates a random noise factor to account for unpredictability and stochasticity in the behavior of real-world entities, which also fits the MPCD method.</p></li>
</ul>
<p>MPCD particles are represented as continuously moving points on a plane, following a continuous trajectory (off-lattice). Particle positions are updated according to the <a class="reference internal" href="../Algorithm/Algorithm.html#eq-stream"><span class="std std-ref">Streaming step</span></a>, which for Vicsek MPCD becomes</p>
<div class="math-wrapper docutils container" id="eq-positionvicsek">
<span id="equation-eq-positionvicsek"></span><div class="math notranslate nohighlight" id="eq-positionvicsek">
<span id="equation-eq-positionvicsek"></span><span class="eqno">(8)<a class="headerlink" href="#eq-positionvicsek" title="Permalink to this equation">#</a></span>\[\vec{r}_i(t+\delta t) = \vec{r}_i(t)+\delta t \cdot v_0 \cdot \vec{u}_i(t) ,\]</div>
</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\vec{r}_i(t+\delta t)\)</span> is the position of particle <span class="math notranslate nohighlight">\(i\)</span> at time <span class="math notranslate nohighlight">\(t + \delta t\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(\vec{r}_i(t)\)</span> is the current position of particle <span class="math notranslate nohighlight">\(i\)</span> at time <span class="math notranslate nohighlight">\(t\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(\delta t\)</span> is the time step;</p></li>
<li><p><span class="math notranslate nohighlight">\(v_0\)</span> is the constant speed of the particle, which is drawn from a uniform distribution;</p></li>
<li><p><span class="math notranslate nohighlight">\(\vec{u}_i(t)\)</span> is the normalized heading (polar orientation vector) of particle <span class="math notranslate nohighlight">\(i\)</span> at time <span class="math notranslate nohighlight">\(t\)</span>;</p></li>
</ul>
<p>The velocity alignment occurs through an <a class="reference internal" href="#srd"><span class="std std-ref">SRD-like collision operation</span></a>, in which the orientation of each fluid particle at time <span class="math notranslate nohighlight">\(t + 1\)</span> is rotated to align with the averag the orientation of the cell, subject to noise.</p>
<div class="math-wrapper docutils container" id="eq-velocityvicsek">
<span id="equation-eq-velocityvicsek"></span><div class="math notranslate nohighlight" id="eq-velocityvicsek">
<span id="equation-eq-velocityvicsek"></span><span class="eqno">(9)<a class="headerlink" href="#eq-velocityvicsek" title="Permalink to this equation">#</a></span>\[\vec{u}_i(t+\delta t) = \boldsymbol{\Omega}_{\theta_i} \cdot \vec{u}_i(t) ,\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\vec{u}_i(t+\delta t)\)</span> is the updated velocity vector of particle <span class="math notranslate nohighlight">\(i\)</span> at time <span class="math notranslate nohighlight">\(t + \delta t\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{\Omega}_\theta\)</span> is the <a class="reference internal" href="#srd"><span class="std std-ref">rotation operator</span></a>, but with the direction of motion</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\theta_i (t+\delta t)= \left\langle \theta(t) \right\rangle_c + \zeta_i ,\]</div>
</div>
<p>where the first term, represents the cell-averaged direction and the second term is a noise <span class="math notranslate nohighlight">\(\zeta_i\)</span>, which is a random angle drawn uniformly from the interval <span class="math notranslate nohighlight">\([- \pi\eta, \pi\eta]\)</span>, where <span class="math notranslate nohighlight">\(\eta\)</span> represents the width of the angular distribution, which is tied to the MPCD activity parameter as <span class="math notranslate nohighlight">\(\alpha = 1 - \eta\)</span>.</p>
<p>The Vicsek MPCD collision operation is implemented with a keycode of <code class="docutils literal notranslate"><span class="pre">7</span></code>.
To use it, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;collOp&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">7</span>
</pre></div>
</div>
<p>To set the width of the noise <span class="math notranslate nohighlight">\(\eta=1-\alpha\)</span>, the activity must be set (<strong>inside</strong> the “species” array):</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;act&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.6</span>
</pre></div>
</div>
</section>
<section id="anderson-active-polar-mpcd">
<h4>Anderson-active polar MPCD<a class="headerlink" href="#anderson-active-polar-mpcd" title="Permalink to this heading">#</a></h4>
<p>This collision operator modifies the <a class="reference internal" href="#andersen"><span class="std std-ref">Andersen-thermostatted collision operator</span></a>. In this active polar model, MPCD particles are driven towards a preferred speed in the local direction of motion. The Anderson-active polar collision operator is</p>
<div class="math-wrapper docutils container" id="eq-aapop">
<span id="equation-eq-aapop"></span><div class="math notranslate nohighlight" id="eq-aapop">
<span id="equation-eq-aapop"></span><span class="eqno">(10)<a class="headerlink" href="#eq-aapop" title="Permalink to this equation">#</a></span>\[\vec{\Xi}^\mathrm{AAP}(t) = \tau\left[ \alpha \hat{v}_c - \vec{v}_i \right] + \vec{\xi}_i - \left\langle \vec{\xi}_j \right\rangle_c ,\]</div>
</div>
<p>where the last two terms are the same as <a class="reference internal" href="#eq-andersenop"><span class="std std-ref">Andersen-thermostatted MPCD</span></a>, but the first term is a self-propulsion term that drives the individual particle velocity towards a magnitude of <span class="math notranslate nohighlight">\(\alpha\)</span> in the direction <span class="math notranslate nohighlight">\(\hat{v}_c=\vec{v}_c/\left|\vec{v}_c\right|\)</span>.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span> - represents the target speed.</p></li>
<li><p><span class="math notranslate nohighlight">\(\tau\)</span> - is a relaxation rate parameter that should be in the range <span class="math notranslate nohighlight">\(0&lt;\tau&lt;1\)</span>.</p></li>
</ul>
<p>Effectively, this collision operator computes a new velocity for each fluid particle within a cell. It is composed of the center of mass velocity of the cell, a random direction of the center of mass, minus the sum of all random velocities within the cell. Importantly, this collision operator conserves momentum, which leads to more physically realistic particle behavior.</p>
<p>The Anderson-active polar MPCD collision operation is implemented with a keycode of <code class="docutils literal notranslate"><span class="pre">11</span></code>.
To use it, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;collOp&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">11.</span>
</pre></div>
</div>
<p>The target speed <span class="math notranslate nohighlight">\(\alpha\)</span> and relaxation rate parameter <span class="math notranslate nohighlight">\(\tau\)</span> must be set. However, for historical reasons, the target speed is set <strong>inside</strong> the “species” array, while the relaxation rate is set <strong>outside</strong>:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;tau&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span>
<span class="nt">&quot;species&quot;</span><span class="p">:</span>
<span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;act&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.6</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">],</span>
</pre></div>
</div>
</section>
<section id="langevin-active-polar-mpcd">
<h4>Langevin-active polar MPCD<a class="headerlink" href="#langevin-active-polar-mpcd" title="Permalink to this heading">#</a></h4>
<p>Just as the Andersen-thermostatted MPCD can be modified with a self-propulsion term, so can the <a class="reference internal" href="#langevin"><span class="std std-ref">Langevin-thermostatted MPCD</span></a>. By adding the <a class="reference internal" href="#eq-aapop"><span class="std std-ref">same self-propulsion term</span></a> to the <a class="reference internal" href="#eq-langevinop"><span class="std std-ref">Langevin collision operator</span></a>, we get the Langevin-active polar collision operator</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\vec{\Xi}^\mathrm{LAP} = \tau\left[ \alpha \hat{v}_c - \vec{v}_i \right] + a\left(\vec{v}_i - \vec{v}_{c}\right) - b\left( \vec{\xi}_i - \sum_j^{N_c} \frac{\vec{\xi}_j}{N_c} \right) ,\]</div>
</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(a = \frac{2m- \gamma \delta t}{2m+ \gamma \delta t}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(b = \frac{2\sqrt{\gamma \delta t}}{2m + \gamma \delta t}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(m\)</span> is the mass of the particle.</p></li>
<li><p><span class="math notranslate nohighlight">\(\vec{v}_i\)</span> is the velocity of the particle.</p></li>
<li><p><span class="math notranslate nohighlight">\(\vec{v}_{cm}\)</span> stands for the center of mass velocity of the cell.</p></li>
<li><p><span class="math notranslate nohighlight">\(\gamma\)</span> is the viscous friction coefficient that opposes the motion of the fluid particles.</p></li>
<li><p><span class="math notranslate nohighlight">\(\vec{\xi}_i\)</span> white noise constant.</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span> - represents the target speed.</p></li>
<li><p><span class="math notranslate nohighlight">\(\tau\)</span> - is a relaxation rate parameter.</p></li>
</ul>
<p>The Anderson-active polar MPCD collision operation is implemented with a keycode of <code class="docutils literal notranslate"><span class="pre">12</span></code>.
To use it, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;collOp&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">12.</span>
</pre></div>
</div>
<p>The target speed <span class="math notranslate nohighlight">\(\alpha\)</span> and relaxation rate parameter <span class="math notranslate nohighlight">\(\tau\)</span> must be set. However, for historical reasons, the target speed is set <strong>inside</strong> the “species” array, while the relaxation rate is set <strong>outside</strong>:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;tau&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span>
<span class="nt">&quot;species&quot;</span><span class="p">:</span>
<span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;act&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.6</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">],</span>
</pre></div>
</div>
</section>
</section>
<section id="multiphase-mpcd">
<span id="multiphasecollop"></span><h3>Multiphase MPCD<a class="headerlink" href="#multiphase-mpcd" title="Permalink to this heading">#</a></h3>
<p>To introduce different fluid-species with different properties to the system, <code class="docutils literal notranslate"><span class="pre">&quot;species&quot;</span></code> array in the <code class="docutils literal notranslate"><span class="pre">.json</span></code> file gets several elements. The number of elements is equal to the number of fluid-species. For instance if there are two fluid-species with different activities, the following changes should be applied</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;species&quot;</span><span class="p">:</span>
<span class="p">[</span>
  <span class="p">{</span>
    <span class="s2">&quot;comment&quot;</span><span class="p">:</span> <span class="s2">&quot;MPCD species 1&quot;</span><span class="p">,</span>
    <span class="o">...</span><span class="p">,</span>
    <span class="o">...</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="s2">&quot;comment&quot;</span><span class="p">:</span> <span class="s2">&quot;MPCD species 2&quot;</span><span class="p">,</span>
    <span class="o">...</span><span class="p">,</span>
    <span class="o">...</span>
  <span class="p">}</span>
<span class="p">],</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Other properties mentioned earlier in this section should be initialized for each fluid-species based on the required properties, otherwise the default values are assumed.</p></li>
</ul>
</div>
<p>One reason to have multiple species might be to include tracer particles — a small number of MPCD fluid-particles whose trajectories are all tracked.
Another reason might be to simulate phase separating fluids.</p>
<section id="phase-separation">
<span id="phaseseparation"></span><h4>Phase separation<a class="headerlink" href="#phase-separation" title="Permalink to this heading">#</a></h4>
<p>Multiphase fluids are implemented in this simulator by allowing for several species of particles with species-wide properties (mass, density, …)
to coexist and interact through tuneable interactions.</p>
<p>A multi-phase mixture can be described by a Landau-Ginzburg free energy functional depending on the local compositional order parameter <em>𝜙</em>,
defined as</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[F = \int d^d r (\frac{\tau}{2}\phi^2+\frac{b}{4}\phi^4+\frac{\kappa}{2}(\nabla \phi)^2) ,\]</div>
</div>
<p>where <em>d</em> is the number of dimensions in the system, <em>b</em> and <em>τ</em> describe the bulk dynamic and phase separation, and <em>𝜅</em> is a surface tension
coefficient <a class="reference internal" href="../References/References.html#cates2018" id="id26"><span>[Cates2018]</span></a>. Minimising this free energy with the Euler-Lagrange equation reveals the equation of motion for the system.
Previous MPCD methods  for phase separating mixtures have utilized supercell <a class="reference internal" href="../References/References.html#eisenstecken2018" id="id27"><span>[Eisenstecken2018]</span></a> and not included surface tension.</p>
<p>To apply the equations of motion obtained through the previous paragraph, the local compositional order must be calculated. In MPCD,
the compositional order at the scale of a cell consists of a series of Dirac delta distributions: each particle belongs to exactly one species, which means that computing the gradient in compositional order, which is essential for accurate surface tension simulation.</p>
<p>In NIAMH-MPCD, the compositional order parameter is estimated as a quadratic function, which allows for the gradient to be computed within each cell. The contributions derived from the relevant free energy
are superimposed on any given collision operators <a class="reference internal" href="../References/References.html#koch2023" id="id28"><span>[Koch2023]</span></a>. This algorithm can therefore resolve surface tension effects up to the
cell-length scale. This method still works for <span class="math notranslate nohighlight">\(N\geq2\)</span> fluid species by running the same algorithm for each pair of species, and so a variety of multiphase fluids can be simulated.</p>
</section>
<section id="interaction-matrix">
<h4>Interaction matrix<a class="headerlink" href="#interaction-matrix" title="Permalink to this heading">#</a></h4>
<p>Each fluid-species has a different interaction with all other fluid-species in a multiphase fluids and this matrix specifies how they interact, as described in the <a class="reference internal" href="#chaptercollop"><span class="std std-ref">collision operator</span></a> section. To set the interaction matrix, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file <strong>inside</strong> the “species” array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;interMatr&quot;</span><span class="p">:</span>    <span class="p">[</span><span class="o">&lt;</span><span class="n">value1</span><span class="o">&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="n">value2</span><span class="o">&gt;</span><span class="p">,</span><span class="o">...</span><span class="p">],</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It <strong>must</strong> be of the same length as the number of fluid-species. Default will autopopulate with zeros, <code class="docutils literal notranslate"><span class="pre">[0,...]</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method has not yet been published on and so should be seen as experimental and not to be employed by users.</p>
</div>
</section>
</section>
<section id="external-fields">
<h3>External fields<a class="headerlink" href="#external-fields" title="Permalink to this heading">#</a></h3>
<p>External forces may be applied to the fluid and when they are, they essentially supplement the collision operation.</p>
<section id="gravitational-acceleration">
<span id="grav"></span><h4>Gravitational acceleration<a class="headerlink" href="#gravitational-acceleration" title="Permalink to this heading">#</a></h4>
<p>An external forcing can be applied to the entire fluid. This is done through a “gravitational” acceleration <span class="math notranslate nohighlight">\(\vec{g}\)</span>. To set it, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;grav&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">9.8</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">],</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The provided array must be 3D, even if the system is 2D.</p></li>
<li><p>A pressure gradient <span class="math notranslate nohighlight">\(\vec{nabla}P\)</span> is equivalent to gravitational acceleration times mass density <span class="math notranslate nohighlight">\(\rho\vec{g}\)</span>. This is a convenient way to set a pressure gradient.</p></li>
<li><p>The default value is [0,0,0].</p></li>
</ul>
</div>
</section>
<section id="magnetic-field">
<span id="magfield"></span><h4>Magnetic field<a class="headerlink" href="#magnetic-field" title="Permalink to this heading">#</a></h4>
<p>A constant external magnetic field <span class="math notranslate nohighlight">\(\vec{H}\)</span> can apply torques to the nematogens, causing the fluid-particle orientations <span class="math notranslate nohighlight">\(\vec{u}_i\)</span> to rotate to align with the field. The magnitude of the torque applied to the nematogen is proportional to <span class="math notranslate nohighlight">\(\chi ({\vec u}_i {\cdot} {\vec H})\)</span> in which the <span class="math notranslate nohighlight">\(\chi\)</span> is the <a class="reference internal" href="#magsus"><span class="std std-ref">magnetic susceptibility</span></a>. The free energy associated to this effect is given by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[f_\text{mag} = -\frac{1}{2} \chi_M H^2 \sin^2(\varepsilon),\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\varepsilon\)</span> is the angle between the nematogen orientation and the magnetic field and <span class="math notranslate nohighlight">\(\chi_M\)</span> is a magnetic susceptibility which sets the strength of this effect.</p>
<p>To set the magnetic field, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file (outside of the species array):</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;mag&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">],</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The provided array must be 3D, even if the system is 2D.</p></li>
<li><p>The default value is [0,0,0].</p></li>
</ul>
</div>
<section id="magnetic-susceptibility">
<span id="magsus"></span><h5>Magnetic susceptibility<a class="headerlink" href="#magnetic-susceptibility" title="Permalink to this heading">#</a></h5>
<p>A <a class="reference internal" href="#magfield"><span class="std std-ref">magnetic field :math:`{vec H}`</span></a> can be applied to the system, which could bias the MPCD particle orientations. The susceptibility of the director to a magnetic field <span class="math notranslate nohighlight">\(\chi\)</span> controls the rotational response of the particles. The magnitude of the torque applied to the nematogen is proportional to <span class="math notranslate nohighlight">\(\chi ({\vec u}_i {\cdot} {\vec H})\)</span> in which the <span class="math notranslate nohighlight">\({\vec u}_i\)</span> is each particle’s orientation.</p>
<p>To set the magnetic susceptibility, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file inside of the species array:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;magSusc&quot;</span><span class="p">:</span><span class="w">    </span><span class="mf">0.001</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0.001.</p>
</div>
</section>
</section>
<section id="friction-coefficient">
<span id="damping"></span><h4>Friction coefficient<a class="headerlink" href="#friction-coefficient" title="Permalink to this heading">#</a></h4>
<p>A friction coefficient can be included in any of the collision operators to dampen hydrodynamics. By acting as a local momenutm sink, this damping lets the system go from wet to dry. The damping coefficient can take values in <span class="math notranslate nohighlight">\([0,1]\)</span>. To set it, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;damp&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.1</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The default value is 0.</p></li>
</ul>
</div>
</section>
</section>
</section>
<section id="boundary-conditions">
<span id="chapterbc"></span><h2><a class="toc-backref" href="#id45" role="doc-backlink">Boundary conditions</a><a class="headerlink" href="#boundary-conditions" title="Permalink to this heading">#</a></h2>
<p id="subsection-boundarysurfaces">All simulations require boundary conditions.
Setting the <a class="reference internal" href="#systemdomain"><span class="std std-ref">domain</span></a> is not sufficient—the boundary conditions must also be set.</p>
<p>Creating surfaces to define the fluid control volume establishes the fluid domain over which the hydrodynamic interactions take place.
For this algorithm, boundary conditions are applied directly to fluid particles that impinge on the surfaces.</p>
<p>The following steps are required:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#subsection-boundarysurfaces"><span class="std std-ref">Surface definitions</span></a></p></li>
<li><p><a class="reference internal" href="#subsection-boundaryrules"><span class="std std-ref">Boundary condition rules</span></a></p></li>
</ul>
<p>These two processes can model a wide variety of fluid settings, including open systems (through periodic boundary conditions), channels and confinement in complex environments.</p>
<p>Boundary condition properties are typically set within the <code class="docutils literal notranslate"><span class="pre">&quot;BC&quot;</span></code> array (see <a class="reference internal" href="../Input/inputFiles.html#bcinput"><span class="std std-ref">BC tag table</span></a>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;BC&quot;</span><span class="p">:</span>
<span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">&quot;comment&quot;</span><span class="p">:</span> <span class="s2">&quot;BC 1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;tag&gt;&quot;</span><span class="p">:</span>  <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="o">...</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">&quot;comment&quot;</span><span class="p">:</span> <span class="s2">&quot;BC&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;tag&gt;&quot;</span><span class="p">:</span>  <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="o">...</span>
    <span class="p">},</span>
    <span class="o">...</span>
<span class="p">],</span>
</pre></div>
</div>
<section id="surfaces">
<h3>Surfaces<a class="headerlink" href="#surfaces" title="Permalink to this heading">#</a></h3>
<p>All boundaries are defined by an implicit surface equation <span class="math notranslate nohighlight">\(S(\vec{x})=0\)</span>,
where <span class="math notranslate nohighlight">\(\vec{x}= (x,y,z)\)</span> are points on the surface.
There are multiple forms of implemented surfaces, which can be combined (setting non-zero surface parameters) or removed (setting surface parameters to zero).</p>
<section id="standard-surfaces">
<span id="standardsurfaces"></span><h4>Standard surfaces<a class="headerlink" href="#standard-surfaces" title="Permalink to this heading">#</a></h4>
<p>Standard surfaces have the form,</p>
<div class="math-wrapper docutils container" id="eq-surface">
<span id="equation-eq-surface"></span><div class="math notranslate nohighlight" id="eq-surface">
<span id="equation-eq-surface"></span><span class="eqno">(11)<a class="headerlink" href="#eq-surface" title="Permalink to this equation">#</a></span>\[S^S(\vec{x})=[A_x^{-1}\left(x-Q_x\right)]^{p_x} + [A_y^{-1}\left(y-Q_y\right)]^{p_y} + [A_z^{-1}\left(z-Q_z\right)]^{p_z} - R^{p_R} = 0\]</div>
</div>
<p>where the surface parameters represent the surface position’s <span class="math notranslate nohighlight">\(\vec{Q}=(Q_x,Q_y,Q_z)\)</span>, surface coefficient’s <span class="math notranslate nohighlight">\(\vec{A}=(A_x,A_y,A_z)\)</span>, surface power’s <span class="math notranslate nohighlight">\((p_x,p_y,p_z,p_R)\)</span> and radius <span class="math notranslate nohighlight">\(R\)</span>. Writing surfaces in this way is versatile and enables <a class="reference internal" href="#eq-surfaceplane1"><span class="std std-ref">planes</span></a>, <a class="reference internal" href="#eq-surfacesphere"><span class="std std-ref">spheres</span></a>, <a class="reference internal" href="#eq-surfaceellipsoid"><span class="std std-ref">ellipsoids</span></a>, <a class="reference internal" href="#eq-surfacecylinder"><span class="std std-ref">cylinders</span></a>, <a class="reference internal" href="#eq-surfacesquircle"><span class="std std-ref">squircles</span></a> and <a class="reference internal" href="#eq-surfacesuperellipsoid"><span class="std std-ref">superellipsoids</span></a> to be created</p>
<p>Boundary properties can be created inside the input, using</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;BC&quot;</span><span class="p">:</span>
<span class="p">[</span>
  <span class="p">{</span>
    <span class="s2">&quot;comment&quot;</span><span class="p">:</span>      <span class="s2">&quot;Boundary properties&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Q&quot;</span><span class="p">:</span>            <span class="p">[</span><span class="n">Qx</span><span class="p">,</span> <span class="n">Qy</span><span class="p">,</span> <span class="n">Qz</span><span class="p">],</span>
    <span class="s2">&quot;aInv&quot;</span><span class="p">:</span>         <span class="p">[</span><span class="n">Ax</span><span class="p">,</span> <span class="n">Ay</span><span class="p">,</span> <span class="n">Az</span><span class="p">],</span>
    <span class="s2">&quot;P&quot;</span><span class="p">:</span>            <span class="p">[</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="n">pz</span><span class="p">,</span> <span class="n">pR</span><span class="p">],</span>
    <span class="s2">&quot;R&quot;</span><span class="p">:</span>            <span class="n">R</span>
  <span class="p">}</span>
<span class="p">],</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>2D surfaces can be defined using the same surface parameters as 3D.
These are slices of 3D surfaces in the <span class="math notranslate nohighlight">\(xy\)</span> plane, where <span class="math notranslate nohighlight">\(z=0\)</span>.</p>
</div>
<ol class="arabic simple">
<li><p><strong>Plane</strong></p></li>
</ol>
<blockquote>
<div><p>To construct a plane, set <span class="math notranslate nohighlight">\(p_x=p_y=p_z=p_R=1\)</span>,
<span class="math notranslate nohighlight">\(Q_x=Q_y=Q_z=0\)</span> and <span class="math notranslate nohighlight">\(R=d\)</span> to give the surface equation</p>
<div class="math-wrapper docutils container" id="eq-surfaceplane1">
<span id="equation-eq-surfaceplane1"></span><div class="math notranslate nohighlight" id="eq-surfaceplane1">
<span id="equation-eq-surfaceplane1"></span><span class="eqno">(12)<a class="headerlink" href="#eq-surfaceplane1" title="Permalink to this equation">#</a></span>\[S(\vec{x})= A_x x + A_y y + A_z z  - d = 0\]</div>
</div>
<p>Describing a plane with normal vector <span class="math notranslate nohighlight">\(\hat{n} = (A_x,A_y,A_z)\)</span> and located at a distance <span class="math notranslate nohighlight">\(d\)</span> from the origin.
Alternatively, can write the surface equation with <span class="math notranslate nohighlight">\(R=0\)</span> so that</p>
<div class="math-wrapper docutils container" id="eq-surfaceplane2">
<span id="equation-eq-surfaceplane2"></span><div class="math notranslate nohighlight" id="eq-surfaceplane2">
<span id="equation-eq-surfaceplane2"></span><span class="eqno">(13)<a class="headerlink" href="#eq-surfaceplane2" title="Permalink to this equation">#</a></span>\[S(\vec{x})= A_x (x-Q_x) + A_y(y-Q_y) + A_z (z-Q_z) = 0\]</div>
</div>
<p>with the perpendicular distance from the origin as <span class="math notranslate nohighlight">\(A \cdot Q = d\)</span>.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/Plane.png"><img alt="Logo" src="../_images/Plane.png" style="width: 216.0px; height: 216.0px;" /></a>
</figure>
<p>An example input for a plane with the normal <span class="math notranslate nohighlight">\(\hat{n}=(0,1,0)\)</span>, located at a distance <span class="math notranslate nohighlight">\(L_y=75\)</span> from the origin,</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;comment&quot;</span><span class="p">:</span><span class="w">      </span><span class="s2">&quot;Plane BC&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;Q&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;aInv&quot;</span><span class="p">:</span><span class="w">         </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;P&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;R&quot;</span><span class="p">:</span><span class="w">            </span><span class="mi">75</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><strong>Sphere</strong></p></li>
</ol>
<blockquote>
<div><p>To construct a sphere, <span class="math notranslate nohighlight">\(p_x=p_y=p_z=p_R=2\)</span>,
<span class="math notranslate nohighlight">\(A_x=A_y=A_z=1\)</span> and <span class="math notranslate nohighlight">\(R\neq0\)</span> to give the surface equation</p>
<div class="math-wrapper docutils container" id="eq-surfacesphere">
<span id="equation-eq-surfacesphere"></span><div class="math notranslate nohighlight" id="eq-surfacesphere">
<span id="equation-eq-surfacesphere"></span><span class="eqno">(14)<a class="headerlink" href="#eq-surfacesphere" title="Permalink to this equation">#</a></span>\[S(\vec{x})= \left(x-Q_x\right)^2 + \left(y-Q_y\right)^2 + \left(z-Q_z\right)^2  - R^2 = 0\]</div>
</div>
<p>Describing a sphere centred at <span class="math notranslate nohighlight">\(\vec{Q} = (Q_x,Q_y,Q_z)\)</span> with a radius <span class="math notranslate nohighlight">\(R\)</span>.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/Sphere.png"><img alt="Logo" src="../_images/Sphere.png" style="width: 216.0px; height: 216.0px;" /></a>
</figure>
<p>An example input for a sphere with a radius <span class="math notranslate nohighlight">\(R=6\)</span> and the centre coordinates <span class="math notranslate nohighlight">\(\vec{Q}=(10,35,75)\)</span> can be constructed with the input parameters:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;comment&quot;</span><span class="p">:</span><span class="w">      </span><span class="s2">&quot;Sphere BC&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;Q&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">35</span><span class="p">,</span><span class="w"> </span><span class="mi">75</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;aInv&quot;</span><span class="p">:</span><span class="w">         </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;P&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;R&quot;</span><span class="p">:</span><span class="w">            </span><span class="mi">6</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p><strong>Ellipsoid</strong></p></li>
</ol>
<blockquote>
<div><p>To construct an ellipsoid, <span class="math notranslate nohighlight">\(p_x=p_y=p_z=p_R=2\)</span> and
<span class="math notranslate nohighlight">\(A_x=\frac{1}{a}, A_z=\frac{1}{b}, A_z=\frac{1}{c}\)</span> and <span class="math notranslate nohighlight">\(R=1\)</span> to give the surface equation</p>
<div class="math-wrapper docutils container" id="eq-surfaceellipsoid">
<span id="equation-eq-surfaceellipsoid"></span><div class="math notranslate nohighlight" id="eq-surfaceellipsoid">
<span id="equation-eq-surfaceellipsoid"></span><span class="eqno">(15)<a class="headerlink" href="#eq-surfaceellipsoid" title="Permalink to this equation">#</a></span>\[S(\vec{x})= \left(\frac{x-Q_x}{a}\right)^2 + \left(\frac{y-Q_y}{b}\right)^2 + \left(\frac{z-Q_z}{c}\right)^2  - 1 = 0\]</div>
</div>
<p>Describing an ellipsoid centred at <span class="math notranslate nohighlight">\(\vec{Q} = (Q_x,Q_y,Q_z)\)</span> with principle semi-axes <span class="math notranslate nohighlight">\(a, b, c\)</span>.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/Ellipsoid.png"><img alt="Logo" src="../_images/Ellipsoid.png" style="width: 216.0px; height: 216.0px;" /></a>
</figure>
<p>An example ellipsoid input with semi-axes <span class="math notranslate nohighlight">\(a^{-1}=6\)</span>, <span class="math notranslate nohighlight">\(b^{-1}=20\)</span> and <span class="math notranslate nohighlight">\(c^{-1}=1\)</span> at the centre coordinates <span class="math notranslate nohighlight">\(\vec{Q}=(10,35,75)\)</span> can be constructed with the input parameters:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;comment&quot;</span><span class="p">:</span><span class="w">      </span><span class="s2">&quot;Ellipsoid BC&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;Q&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">35</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;aInv&quot;</span><span class="p">:</span><span class="w">         </span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;P&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;R&quot;</span><span class="p">:</span><span class="w">            </span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p><strong>Cylinder</strong></p></li>
</ol>
<blockquote>
<div><p>A cylinder aligned along <span class="math notranslate nohighlight">\(\hat{e}_z\)</span> can be constructed using <span class="math notranslate nohighlight">\(p_x=p_y=p_R=2\)</span>, <span class="math notranslate nohighlight">\(A_x=A_y=1, A_z=0\)</span> and <span class="math notranslate nohighlight">\(R\neq 0\)</span>.</p>
<div class="math-wrapper docutils container" id="eq-surfacecylinder">
<span id="equation-eq-surfacecylinder"></span><div class="math notranslate nohighlight" id="eq-surfacecylinder">
<span id="equation-eq-surfacecylinder"></span><span class="eqno">(16)<a class="headerlink" href="#eq-surfacecylinder" title="Permalink to this equation">#</a></span>\[S(\vec{x})= \left(x-Q_x\right)^2 + \left(y-Q_y\right)^2 - R^2 = 0\]</div>
</div>
<p>Describing an cylinder centred at <span class="math notranslate nohighlight">\(\vec{Q} = (Q_x,Q_y)\)</span> on the <span class="math notranslate nohighlight">\(xy\)</span> plane with radius <span class="math notranslate nohighlight">\(R\)</span>.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/Cylinder.png"><img alt="Logo" src="../_images/Cylinder.png" style="width: 223.2px; height: 209.4px;" /></a>
</figure>
<p>An example input for a cylinder aligned in z-direcctoin with a radius <span class="math notranslate nohighlight">\(R=60\)</span> and the centre coordinates <span class="math notranslate nohighlight">\(\vec{Q}=(10,35,0)\)</span> (<span class="math notranslate nohighlight">\(Q_z\)</span> is arbitrary) can be constructed with the input parameters:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;comment&quot;</span><span class="p">:</span><span class="w">      </span><span class="s2">&quot;Cylinder BC&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;Q&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">35</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;aInv&quot;</span><span class="p">:</span><span class="w">         </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;P&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;R&quot;</span><span class="p">:</span><span class="w">            </span><span class="mi">60</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" id="squircle" start="5">
<li><p><strong>Squircle</strong></p></li>
</ol>
<blockquote>
<div><p>A squircle is a surface that is intermediate between a sphere and a cube.
The construction of a squircle has powers <span class="math notranslate nohighlight">\(p_x=p_y=p_z=p_R&gt;2\)</span> and even, with <span class="math notranslate nohighlight">\(A_x=A_y=A_z=1\)</span></p>
<div class="math-wrapper docutils container" id="eq-surfacesquircle">
<span id="equation-eq-surfacesquircle"></span><div class="math notranslate nohighlight" id="eq-surfacesquircle">
<span id="equation-eq-surfacesquircle"></span><span class="eqno">(17)<a class="headerlink" href="#eq-surfacesquircle" title="Permalink to this equation">#</a></span>\[S(\vec{x})= \left(x-Q_x\right)^4 + \left(y-Q_y\right)^4 + \left(z-Q_z\right)^4  - R^4 = 0\]</div>
</div>
<p>Describing a squircle centred at <span class="math notranslate nohighlight">\(\vec{Q} = (Q_x,Q_y,Q_z)\)</span> with a minor radius <span class="math notranslate nohighlight">\(R\)</span>.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/Squircle.png"><img alt="Logo" src="../_images/Squircle.png" style="width: 216.0px; height: 216.0px;" /></a>
</figure>
<p>An example squircle input with a minor radius <span class="math notranslate nohighlight">\(R=8\)</span>, centre coordinates <span class="math notranslate nohighlight">\(\vec{Q}=(16,32,48)\)</span> and powers of <em>4</em> can be constructed with the input parameters:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;comment&quot;</span><span class="p">:</span><span class="w">      </span><span class="s2">&quot;Squircle BC&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;Q&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">48</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;aInv&quot;</span><span class="p">:</span><span class="w">         </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;P&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;R&quot;</span><span class="p">:</span><span class="w">            </span><span class="mi">8</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="6">
<li><p><strong>Superellipsoid</strong></p></li>
</ol>
<blockquote>
<div><p>A superellipse is a closed surface that resembles an ellipse, featuring a semi-major axis and semi-minor axis, but with different shape.
The construction of a superellipse has <span class="math notranslate nohighlight">\(p_x=p_y=p_z=p_R=n\)</span> and
<span class="math notranslate nohighlight">\(A_x=\frac{1}{a}, A_z=\frac{1}{b}, A_z=\frac{1}{c}\)</span> and <span class="math notranslate nohighlight">\(R=1\)</span>.
A super ellipsoid provide an increasingly closer approximation to a cuboid for large positive <span class="math notranslate nohighlight">\(n\)</span>.</p>
<div class="math-wrapper docutils container" id="eq-surfacesuperellipsoid">
<span id="equation-eq-surfacesuperellipsoid"></span><div class="math notranslate nohighlight" id="eq-surfacesuperellipsoid">
<span id="equation-eq-surfacesuperellipsoid"></span><span class="eqno">(18)<a class="headerlink" href="#eq-surfacesuperellipsoid" title="Permalink to this equation">#</a></span>\[S(\vec{x})= \left(\frac{x-Q_x}{a}\right)^n + \left(\frac{y-Q_y}{b}\right)^n + \left(\frac{z-Q_z}{c}\right)^n  - 1 = 0\]</div>
</div>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/SuperEllipsoid.png"><img alt="Logo" src="../_images/SuperEllipsoid.png" style="width: 216.0px; height: 216.0px;" /></a>
</figure>
<p>An example superellipsoid input with with semi-axes <span class="math notranslate nohighlight">\(a^{-1}=6\)</span>, <span class="math notranslate nohighlight">\(b^{-1}=20\)</span> and <span class="math notranslate nohighlight">\(c^{-1}=1\)</span> at the centre coordinates <span class="math notranslate nohighlight">\(\vec{Q}=(10,25,10)\)</span> and powers of <em>8</em> can be constructed with the input parameters:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;comment&quot;</span><span class="p">:</span><span class="w">      </span><span class="s2">&quot;Superellipsoid BC&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;Q&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;aInv&quot;</span><span class="p">:</span><span class="w">         </span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;P&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;R&quot;</span><span class="p">:</span><span class="w">            </span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="additional-surface-forms">
<span id="additionalsurfaces"></span><h4>Additional surface forms<a class="headerlink" href="#additional-surface-forms" title="Permalink to this heading">#</a></h4>
<p>MPCD boundaries are versatile and many possible surface geometries can be implemented.</p>
<section id="slanted-surfaces">
<h5>Slanted surfaces<a class="headerlink" href="#slanted-surfaces" title="Permalink to this heading">#</a></h5>
<p>Any surface can be oriented along a different axis. Simply provide an orientation vector <span class="math notranslate nohighlight">\(\vec{O}=(O_x,O_y,O_z)\)</span> <strong>inside</strong> <code class="docutils literal notranslate"><span class="pre">&quot;bc&quot;</span></code> array.
An example ellipsoid input with semi-axes <span class="math notranslate nohighlight">\(a^{-1}=6\)</span>, <span class="math notranslate nohighlight">\(b^{-1}=20\)</span> and <span class="math notranslate nohighlight">\(c^{-1}=1\)</span> at the centre coordinates <span class="math notranslate nohighlight">\(\vec{Q}=(10,35,75)\)</span> with orientation <span class="math notranslate nohighlight">\(\vec{O}=(0.7071,0.7071,0)\)</span> can be constructed with the input parameters:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;comment&quot;</span><span class="p">:</span><span class="w">      </span><span class="s2">&quot;Ellipsoid BC&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;Q&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">35</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;O&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mf">0.7071</span><span class="p">,</span><span class="mf">0.7071</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;aInv&quot;</span><span class="p">:</span><span class="w">         </span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;P&quot;</span><span class="p">:</span><span class="w">            </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;R&quot;</span><span class="p">:</span><span class="w">            </span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="absolute-value">
<h5>Absolute value<a class="headerlink" href="#absolute-value" title="Permalink to this heading">#</a></h5>
<p>An absolute value operation can be done on each of the terms in the surface equation:</p>
<div class="math-wrapper docutils container" id="eq-surfaceabs">
<span id="equation-eq-surfaceabs"></span><div class="math notranslate nohighlight" id="eq-surfaceabs">
<span id="equation-eq-surfaceabs"></span><span class="eqno">(19)<a class="headerlink" href="#eq-surfaceabs" title="Permalink to this equation">#</a></span>\[S^S(\vec{x}) = \left|A_x^{-1}\left(x-Q_x\right)\right|^{p_x} + \left|A_y^{-1}\left(y-Q_y\right)\right|^{p_y} + \left|A_z^{-1}\left(z-Q_z\right)\right|^{p_z} - R^{p_R} = 0\]</div>
</div>
<p>To turn this on, set the <code class="docutils literal notranslate"><span class="pre">abs</span></code> flag <strong>inside</strong> the <code class="docutils literal notranslate"><span class="pre">&quot;BC&quot;</span></code> to 1 (on):</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;abs&quot;</span><span class="p">:</span><span class="w">          </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0 (off).</p>
</div>
</section>
<section id="non-four-fold-symmetric-surfaces">
<h5>Non-four-fold symmetric surfaces<a class="headerlink" href="#non-four-fold-symmetric-surfaces" title="Permalink to this heading">#</a></h5>
<p>The surfaces given by the <a class="reference internal" href="#eq-surface"><span class="std std-ref">standard</span></a> and <a class="reference internal" href="#eq-surfaceabs"><span class="std std-ref">absolute</span></a> forms are limited to even or four-fold-or-less symmetry. Additional symmetries are possible if we let</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}r &amp;= \left( (x-Q_x)^2 + (y-Q_y)^2 + (z-Q_z)^2 \right)^{1/2} \\
\phi &amp;= \tan^{-1}( (y-Q_y)/(x-Q_x) ) \\
\theta &amp;= \cos^{-1}\left( \frac{z-Q_z}{r} \right) \\
S^S(\vec{x}) &amp;= \left|A_x^{-1}\cos\left( \frac{M \phi}{4} \right )\sin\left( \frac{W \theta}{4} \right )\right|^{p_x} + \left|A_y^{-1}\cos\left( \frac{M \phi}{4} \right )\sin\left( \frac{W \theta}{4} \right )\right|^{p_y} \\
  &amp;\qquad + \left|A_z^{-1}\cos\left( \frac{M \phi}{4} \right )\sin\left( \frac{W \theta}{4} \right )\right|^{p_z} - R^{p_R} = 0 ,\end{split}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\vec{Q}=(Q_x,Q_y,Q_z)\)</span> is the centre of the body, <span class="math notranslate nohighlight">\(\vec{A}=(A_x,A_y,A_z)\)</span> are the surface coefficient, <span class="math notranslate nohighlight">\((p_x,p_y,p_z,p_R)\)</span> are the surface powers and <span class="math notranslate nohighlight">\(R\)</span> is the radius. The arguments <span class="math notranslate nohighlight">\(M\)</span> and <span class="math notranslate nohighlight">\(W\)</span> control the degree of symmetry. They do <strong>not</strong> need to be integers. Examples are given in  <a class="reference internal" href="../References/References.html#gielis" id="id29"><span>[Gielis]</span></a>.</p>
<p>The two rotational symmetries are set for each BC by the <code class="docutils literal notranslate"><span class="pre">&quot;rotSym&quot;</span></code> option. To have a triangular boundary in 2D, set</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;rotSym&quot;</span><span class="p">:</span><span class="w">          </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is [4,4].</p>
</div>
</section>
<section id="wavy-surfaces">
<h5>Wavy surfaces<a class="headerlink" href="#wavy-surfaces" title="Permalink to this heading">#</a></h5>
<p>Modulated planes, spheres and cylinders can be created with surface equations <span class="math notranslate nohighlight">\(S(\vec{x})=S^S(\vec{x})+S^W(\vec{x})\)</span>, combining standard surfaces <span class="math notranslate nohighlight">\(S^{S}(\vec{x})\)</span> with a wavy component <span class="math notranslate nohighlight">\(S^{W}(\vec{x})\)</span> <a class="reference internal" href="../References/References.html#wamsler2024" id="id30"><span>[Wamsler2024]</span></a>.
For a surface indexed by <span class="math notranslate nohighlight">\(b\)</span>, wavy surfaces are implemented with the form</p>
<div class="math-wrapper docutils container" id="eq-surfacewavy">
<span id="equation-eq-surfacewavy"></span><div class="math notranslate nohighlight" id="eq-surfacewavy">
<span id="equation-eq-surfacewavy"></span><span class="eqno">(20)<a class="headerlink" href="#eq-surfacewavy" title="Permalink to this equation">#</a></span>\[S^{W}_b(\vec{x})= B_{b,0}\cos(B_{b,1}S_{b,1}(\vec{x}))\cos(B_{b,2}S_{b,2}(\vec{x}))\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(B_{b,0}\)</span> is a modulation amplitude, <span class="math notranslate nohighlight">\(B_{b,1}\)</span> and <span class="math notranslate nohighlight">\(B_{b,2}\)</span>
are modulation frequencies, and <span class="math notranslate nohighlight">\(S_{b,1}\)</span> and <span class="math notranslate nohighlight">\(S_{b,2}\)</span> define the orientation of the modulation.
By setting one of <span class="math notranslate nohighlight">\(B_{b,1}\)</span> and <span class="math notranslate nohighlight">\(B_{b,2}\)</span> to zero, surfaces can be given waves in one axis (corrugated),
while when both frequencies are non-zero, surfaces take on double modulated surfaces.</p>
<p>The wavy surfaces can be used in the input scripts as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;comment&quot;</span><span class="p">:</span>              <span class="s2">&quot;Wavy BC&quot;</span><span class="p">,</span>
  <span class="n">Wavy</span>  <span class="p">[</span><span class="n">B0</span><span class="p">,</span><span class="n">B1</span><span class="p">,</span><span class="n">B2</span><span class="p">]</span>        <span class="s2">&quot;B0 = amplitube, B1,B2 = wave frequencies&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Depending on the combined <a class="reference internal" href="#eq-surface"><span class="std std-ref">standard surface</span></a> <span class="math notranslate nohighlight">\(S^{S}(\vec{x})\)</span>,
the orientation equations <span class="math notranslate nohighlight">\(S_{b,1}(\vec{x})\)</span> and <span class="math notranslate nohighlight">\(S_{b,2}(\vec{x})\)</span> are given different forms, as outlined below.</p>
<ol class="arabic simple">
<li><p><strong>Wavy planes</strong></p></li>
</ol>
<blockquote>
<div><p>For wavy planes, the orientation functions take the form</p>
<div class="math-wrapper docutils container" id="eq-planewavys1">
<span id="equation-eq-planewavys1"></span><div class="math notranslate nohighlight" id="eq-planewavys1">
<span id="equation-eq-planewavys1"></span><span class="eqno">(21)<a class="headerlink" href="#eq-planewavys1" title="Permalink to this equation">#</a></span>\[\begin{split}S_{b,1}(\vec{x}) &amp;= \frac{A_y x - A_x y}{\sqrt{A_x^2+ A_y^2}} \\
S_{b,2}(\vec{x}) &amp;= \frac{A_x A_z x + A_y A_z y - (A_x^2 + A_y^2) z}{\sqrt{A_x^4 + A_y^4 + 2 A_x^2 A_z^2 + 2 A_y^2 A_z^2 + 2 A_x^2 A_y^2}}\end{split}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(S_{b,1}\)</span> generates longitudinal waves (number set by the frequency <span class="math notranslate nohighlight">\(B_{b,1}\)</span>) and <span class="math notranslate nohighlight">\(S_{b,2}(\vec{x})\)</span> creates latitudinal waves (number set by the frequency <span class="math notranslate nohighlight">\(B_{b,2}\neq0\)</span>).</p>
<p>The accompanying standard surface <span class="math notranslate nohighlight">\(S^S(\vec{x})\)</span>, defines the <a class="reference internal" href="#eq-surfaceplane1"><span class="std std-ref">plane</span></a>.</p>
<div class="table-wrapper colwidths-given docutils container">
<table class="docutils align-center">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><a class="reference internal image-reference" href="../_images/WavyPlane.png"><img alt="../_images/WavyPlane.png" class="align-center" src="../_images/WavyPlane.png" style="width: 95%;" /></a>
</td>
<td><a class="reference internal image-reference" href="../_images/EggPlane.png"><img alt="../_images/EggPlane.png" class="align-center" src="../_images/EggPlane.png" style="width: 95%;" /></a>
</td>
</tr>
<tr class="row-even"><td><p>Corrugated plane for either <span class="math notranslate nohighlight">\(B_{b,1}\neq 0\)</span> or <span class="math notranslate nohighlight">\(B_{b,2}\neq 0\)</span>.</p>
<p>This example has <span class="math notranslate nohighlight">\(B_{b,0} = 0.2\)</span>, <span class="math notranslate nohighlight">\(B_{b,1} = 10\)</span>, <span class="math notranslate nohighlight">\(B_{b,2} = 0\)</span> and <span class="math notranslate nohighlight">\(\vec{A}=(0,1,0)\)</span>, to define a plane with normal in <span class="math notranslate nohighlight">\(\hat{y}\)</span> that has transverse modulation in <span class="math notranslate nohighlight">\(\hat{x}\)</span> direction with amplitude <span class="math notranslate nohighlight">\(0.2\)</span>.</p>
</td>
<td><p>Egg carton plane for both <span class="math notranslate nohighlight">\(B_{b,1}\neq 0\)</span> and <span class="math notranslate nohighlight">\(B_{b,2}\neq 0\)</span>. This example has <span class="math notranslate nohighlight">\(B_{b,0} = 0.2\)</span>, <span class="math notranslate nohighlight">\(B_{b,1} = 10\)</span>, <span class="math notranslate nohighlight">\(B_{b,2} = 10\)</span> and <span class="math notranslate nohighlight">\(\vec{A}=(0,1,0)\)</span>, to define a plane with normal in <span class="math notranslate nohighlight">\(\hat{y}\)</span> that has transverse modulation in <span class="math notranslate nohighlight">\(\hat{x}\)</span> and <span class="math notranslate nohighlight">\(\hat{z}\)</span> direction with amplitude <span class="math notranslate nohighlight">\(0.2\)</span>.</p></td>
</tr>
</tbody>
</table>
</div>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><strong>Wavy spheres</strong></p></li>
</ol>
<blockquote>
<div><p>For wavy spheres, the orientation functions take the form</p>
<div class="math-wrapper docutils container" id="eq-spherewavys1">
<span id="equation-eq-spherewavys1"></span><div class="math notranslate nohighlight" id="eq-spherewavys1">
<span id="equation-eq-spherewavys1"></span><span class="eqno">(22)<a class="headerlink" href="#eq-spherewavys1" title="Permalink to this equation">#</a></span>\[\begin{split}\tan S_{b,1}(\vec{x}) &amp;= \frac{A_y y - Q_y}{A_x x - Q_x} \\
\tan S_{b,2}(\vec{x}) &amp;= \frac{\sqrt{A_x^2(x-Q_x)^2 + A_y^2(y-Q_y)^2}}{A_z(z-Q_z)}\end{split}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(S_{b,1}\)</span> generates longitudinal waves (number set by the frequency <span class="math notranslate nohighlight">\(B_{b,1}\)</span>) and <span class="math notranslate nohighlight">\(S_{b,2}(\vec{x})\)</span> creates latitudinal waves (number set by the frequency <span class="math notranslate nohighlight">\(B_{b,2}\neq0\)</span>).</p>
<p>The accompanying standard surface <span class="math notranslate nohighlight">\(S^S(\vec{x})\)</span>, defines the <a class="reference internal" href="#eq-surfacesphere"><span class="std std-ref">sphere</span></a>.</p>
<div class="table-wrapper colwidths-given docutils container">
<table class="docutils align-center">
<colgroup>
<col style="width: 33.3%" />
<col style="width: 33.3%" />
<col style="width: 33.3%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><a class="reference internal image-reference" href="../_images/LatitudeSphere.png"><img alt="../_images/LatitudeSphere.png" class="align-center" src="../_images/LatitudeSphere.png" style="width: 95%;" /></a>
</td>
<td><a class="reference internal image-reference" href="../_images/LongitudinalSphere.png"><img alt="../_images/LongitudinalSphere.png" class="align-center" src="../_images/LongitudinalSphere.png" style="width: 95%;" /></a>
</td>
<td><a class="reference internal image-reference" href="../_images/eggCartonSphere.png"><img alt="../_images/eggCartonSphere.png" class="align-center" src="../_images/eggCartonSphere.png" style="width: 95%;" /></a>
</td>
</tr>
<tr class="row-even"><td><p>Latitudinal waves for <span class="math notranslate nohighlight">\(B_{b,1} = 0\)</span> and <span class="math notranslate nohighlight">\(B_{b,2}\neq 0\)</span>. This example has <span class="math notranslate nohighlight">\(B_{b,0} = 0.2\)</span>, <span class="math notranslate nohighlight">\(B_{b,1} = 0\)</span>, <span class="math notranslate nohighlight">\(B_{b,2} = 10\)</span> <em>and</em> <span class="math notranslate nohighlight">\(\vec{A}=(1,1,1)\)</span>, to define a sphere that has latitudinal modulation with amplitude <span class="math notranslate nohighlight">\(0.2\)</span>.</p></td>
<td><p>Longitudinal waves for <span class="math notranslate nohighlight">\(B_{b,1} \neq 0\)</span> and <span class="math notranslate nohighlight">\(B_{b,2} = 0\)</span>. This example has <span class="math notranslate nohighlight">\(B_{b,0} = 0.2\)</span>, <span class="math notranslate nohighlight">\(B_{b,1} = 10\)</span>, <span class="math notranslate nohighlight">\(B_{b,2} = 0\)</span> and <span class="math notranslate nohighlight">\(\vec{A}=(1,1,1)\)</span>, to define a sphere that has longitudinal modulation with amplitude <span class="math notranslate nohighlight">\(0.2\)</span>.</p></td>
<td><p>Egg carton waves for <span class="math notranslate nohighlight">\(B_{b,1} \neq 0\)</span> and <span class="math notranslate nohighlight">\(B_{b,2} \neq 0\)</span>. This example has <span class="math notranslate nohighlight">\(B_{b,0} = 0.2\)</span>, <span class="math notranslate nohighlight">\(B_{b,1} = 10\)</span>, <span class="math notranslate nohighlight">\(B_{b,2} = 10\)</span> and <span class="math notranslate nohighlight">\(\vec{A}=(1,1,1)\)</span>, to define a sphere that has both latitudinal and longitudinal modulation with amplitude <span class="math notranslate nohighlight">\(0.2\)</span>.</p></td>
</tr>
</tbody>
</table>
</div>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p><strong>Wavy cylinders</strong></p></li>
</ol>
<blockquote>
<div><p>The two orientation functions <span class="math notranslate nohighlight">\(S_{b,1}(\vec{x})\)</span> and <span class="math notranslate nohighlight">\(S_{b,2}(\vec{x})\)</span> have cylic properties with respect to cylinder orientation along the cartesian direction <span class="math notranslate nohighlight">\(\hat{x},\hat{y},\hat{z}\)</span>.</p>
<p>If the cylinder is oriented in the</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\hat{x}\)</span>-direction, then <span class="math notranslate nohighlight">\(A_x=0\)</span> and <span class="math notranslate nohighlight">\((i,j,k)=(x,y,z)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\hat{y}\)</span>-direction, then <span class="math notranslate nohighlight">\(A_y=0\)</span> and <span class="math notranslate nohighlight">\((i,j,k)=(y,z,x)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\hat{z}\)</span>-direction, then <span class="math notranslate nohighlight">\(A_z=0\)</span> and <span class="math notranslate nohighlight">\((i,j,k)=(z,x,y)\)</span></p></li>
</ul>
<p>The orientation functions then take the form,</p>
<div class="math-wrapper docutils container" id="eq-spherewavys2">
<span id="equation-eq-spherewavys2"></span><div class="math notranslate nohighlight" id="eq-spherewavys2">
<span id="equation-eq-spherewavys2"></span><span class="eqno">(23)<a class="headerlink" href="#eq-spherewavys2" title="Permalink to this equation">#</a></span>\[\begin{split}\tan S_{b,1}(\vec{x}) &amp;= \frac{A_k x_k - Q_k}{A_j x_j - Q_j} \\
\tan S_{b,2}(\vec{x}) &amp;= \frac{\sqrt{A_j^2(x_j-Q_j)^2 + A_k^2(x_k-Q_k)^2}}{A_i(x_i-Q_i)}\end{split}\]</div>
</div>
<p>The accompanying standard surface <span class="math notranslate nohighlight">\(S^S(\vec{x})\)</span>, defining the <a class="reference internal" href="#eq-surfacecylinder"><span class="std std-ref">cylinder</span></a>, has the following form under the cyclic axes,</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[S^S(\vec{x}) = \left(x_j-Q_j \right )^2 + \left(x_k-Q_k \right)^2 - R^2 = 0\]</div>
</div>
<div class="table-wrapper colwidths-given docutils container">
<table class="docutils align-center">
<colgroup>
<col style="width: 33.3%" />
<col style="width: 33.3%" />
<col style="width: 33.3%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><a class="reference internal image-reference" href="../_images/LatitudeCylinder.png"><img alt="../_images/LatitudeCylinder.png" class="align-center" src="../_images/LatitudeCylinder.png" style="width: 95%;" /></a>
</td>
<td><a class="reference internal image-reference" href="../_images/LongitudinalCylinder.png"><img alt="../_images/LongitudinalCylinder.png" class="align-center" src="../_images/LongitudinalCylinder.png" style="width: 95%;" /></a>
</td>
<td><a class="reference internal image-reference" href="../_images/eggCartonCylinder.png"><img alt="../_images/eggCartonCylinder.png" class="align-center" src="../_images/eggCartonCylinder.png" style="width: 95%;" /></a>
</td>
</tr>
<tr class="row-even"><td><p>Latitudinal waves on cylinder for <span class="math notranslate nohighlight">\(B_{b,1} = 0\)</span> and <span class="math notranslate nohighlight">\(B_{b,2} \neq 0\)</span>. This example has <span class="math notranslate nohighlight">\(B_{b,0} = 0.2\)</span>, <span class="math notranslate nohighlight">\(B_{b,1} = 0\)</span>, <span class="math notranslate nohighlight">\(B_{b,2} = 10\)</span> and <span class="math notranslate nohighlight">\(\vec{A}=(1,1,0)\)</span>, to define a cylinder that has latitudinal modulation with amplitude <span class="math notranslate nohighlight">\(0.2\)</span>.</p></td>
<td><p>Longitudinal waves on cylinder for <span class="math notranslate nohighlight">\(B_{b,1} \neq 0\)</span> and <span class="math notranslate nohighlight">\(B_{b,2} = 0\)</span>. This example has <span class="math notranslate nohighlight">\(B_{b,0} = 0.2\)</span>, <span class="math notranslate nohighlight">\(B_{b,1} = 10\)</span>, <span class="math notranslate nohighlight">\(B_{b,2} = 0\)</span> and <span class="math notranslate nohighlight">\(\vec{A}=(1,1,0)\)</span>, to define a cylinder that has longitudinal modulation with amplitude <span class="math notranslate nohighlight">\(0.2\)</span>.</p></td>
<td><p>Egg-carton waves on cylinder for <span class="math notranslate nohighlight">\(B_{b,1} \neq 0\)</span> and <span class="math notranslate nohighlight">\(B_{b,2} \neq 0\)</span>. This example has <span class="math notranslate nohighlight">\(B_{b,0} = 0.2\)</span>, <span class="math notranslate nohighlight">\(B_{b,1} = 10\)</span>, <span class="math notranslate nohighlight">\(B_{b,2} = 10\)</span> and <span class="math notranslate nohighlight">\(\vec{A}=(1,1,0)\)</span>, to define a cylinder that has both latitudinal and longitudinal modulation with amplitude <span class="math notranslate nohighlight">\(0.2\)</span>.</p></td>
</tr>
</tbody>
</table>
</div>
</div></blockquote>
</section>
</section>
</section>
<section id="boundary-rules">
<span id="subsection-boundaryrules"></span><h3>Boundary rules<a class="headerlink" href="#boundary-rules" title="Permalink to this heading">#</a></h3>
<p>Having established a boundary’s surface, it remains to set what rules are obeyed for particles that pass a boundary.</p>
<section id="requirements">
<h4>Requirements<a class="headerlink" href="#requirements" title="Permalink to this heading">#</a></h4>
<p>The implicit representation for the surface has the property that</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(S(\vec{x}) &gt; 0\)</span>, a point is <strong>outside</strong> the surface</p></li>
<li><p><span class="math notranslate nohighlight">\(S(\vec{x}) = 0\)</span>, a point is <strong>on</strong> the surface</p></li>
<li><p><span class="math notranslate nohighlight">\(S(\vec{x}) &lt; 0\)</span>, a point is <strong>inside</strong> the surface.</p></li>
</ul>
<p>Following a streaming step, boundary conditions are applied to an MPCD particle if the particle has passed inside a boundary.
For a particle <span class="math notranslate nohighlight">\(i\)</span> with position <span class="math notranslate nohighlight">\(\vec{x}_i\)</span> this condition is</p>
<div class="math-wrapper docutils container" id="eq-bccondition">
<span id="equation-eq-bccondition"></span><div class="math notranslate nohighlight" id="eq-bccondition">
<span id="equation-eq-bccondition"></span><span class="eqno">(24)<a class="headerlink" href="#eq-bccondition" title="Permalink to this equation">#</a></span>\[S(\vec{x}_i) \leq 0\]</div>
</div>
<p>Boundary conditions are only applied to a particle when the position is exactly on the surface,
which requires tracing back the particle’s position <span class="math notranslate nohighlight">\(\vec{x}_i^*\)</span> to where <span class="math notranslate nohighlight">\(S(\vec{x}_i^*) = 0\)</span>
at time <span class="math notranslate nohighlight">\(t^*\)</span> where <span class="math notranslate nohighlight">\(0&lt;t^*&lt;\delta t\)</span>.
Following boundary rules, the particle resumes streaming for the remaining time <span class="math notranslate nohighlight">\(\delta t-t^*\)</span>.</p>
</section>
<section id="boundary-operators">
<span id="bcoperators"></span><h4>Boundary operators<a class="headerlink" href="#boundary-operators" title="Permalink to this heading">#</a></h4>
<p>Boundary rules are operators on a particle’s position <span class="math notranslate nohighlight">\(\vec{x}_i\)</span>, velocity <span class="math notranslate nohighlight">\(\vec{v}_i\)</span> or orientation properties <span class="math notranslate nohighlight">\(\hat{u}_i\)</span>.
For a general property <span class="math notranslate nohighlight">\(\vec{f}_i (t)\)</span>, the rules have the following form</p>
<div class="math-wrapper docutils container" id="eq-bcoperators1">
<span id="equation-eq-bcoperators1"></span><div class="math notranslate nohighlight" id="eq-bcoperators1">
<span id="equation-eq-bcoperators1"></span><span class="eqno">(25)<a class="headerlink" href="#eq-bcoperators1" title="Permalink to this equation">#</a></span>\[\vec{f}_i(t&gt;t^*) \: \text{+=} \: D_{f,\hat{\nu}}\hat{\nu}\]</div>
</div>
<div class="math-wrapper docutils container" id="eq-bcoperators2">
<span id="equation-eq-bcoperators2"></span><div class="math notranslate nohighlight" id="eq-bcoperators2">
<span id="equation-eq-bcoperators2"></span><span class="eqno">(26)<a class="headerlink" href="#eq-bcoperators2" title="Permalink to this equation">#</a></span>\[\vec{f}_i(t&gt;t^*) \: \text{+=} \: M_{f,\hat{\nu}} \vec{f}_{i,\hat{\nu}}(t&lt;t^*)\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\nu}\)</span> are implemented as each of the cartesian axes <span class="math notranslate nohighlight">\(\hat{x},\hat{y},\hat{z}\)</span>, the local surface normal <span class="math notranslate nohighlight">\(\hat{n}\)</span> and the local surface tangent <span class="math notranslate nohighlight">\(\hat{t}\)</span>.
The properties before and after the boundary rules are applied are <span class="math notranslate nohighlight">\(\vec{f}_i(t&lt;t^*)\)</span> and <span class="math notranslate nohighlight">\(\vec{f}_i(t&gt;t^*)\)</span>.
The <a class="reference internal" href="#eq-bcoperators1"><span class="std std-ref">shift operator</span></a> is an additive shift on vector <span class="math notranslate nohighlight">\(\vec{f}_i\)</span> in direction <span class="math notranslate nohighlight">\(\hat{\nu}\)</span> with magnitude <span class="math notranslate nohighlight">\(D_{f,\hat{\nu}}\)</span>
and the <a class="reference internal" href="#eq-bcoperators2"><span class="std std-ref">multiplier operator</span></a> <span class="math notranslate nohighlight">\(M_{f,\hat{\nu}}\)</span> acts on the projection <span class="math notranslate nohighlight">\(\vec{f}_{i,\hat{\nu}}\)</span> of the property <span class="math notranslate nohighlight">\(\vec{f}_i\)</span> in the direction <span class="math notranslate nohighlight">\(\hat{\nu}\)</span>.</p>
<p>Defaults for no applied conditions are <span class="math notranslate nohighlight">\(D_{f,\hat{\nu}} = 0\)</span> and <span class="math notranslate nohighlight">\(M_{f,\hat{\nu}} = 1\)</span>,
leaving all components of <span class="math notranslate nohighlight">\(f_i\)</span> unchanged and without shifts.
The default operator values in the input scripts are shown below, which can be edited to define particular boundary condition.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;comment&quot;</span><span class="p">:</span>      <span class="s2">&quot;position operators&quot;</span><span class="p">,</span>
  <span class="n">DN</span>  <span class="mi">0</span>           <span class="s2">&quot;position shift in normal direction&quot;</span><span class="p">,</span>
  <span class="n">DT</span>  <span class="mi">0</span>           <span class="s2">&quot;position shift in tangential direction&quot;</span><span class="p">,</span>

  <span class="s2">&quot;comment&quot;</span><span class="p">:</span>      <span class="s2">&quot;velocity operators&quot;</span><span class="p">,</span>
  <span class="n">DVN</span> <span class="mi">0</span>           <span class="s2">&quot;velocity added in the normal direction&quot;</span><span class="p">,</span>
  <span class="n">DVT</span> <span class="mi">0</span>           <span class="s2">&quot;velocity added in the tangential direction&quot;</span><span class="p">,</span>
  <span class="n">DVxyz</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>   <span class="s2">&quot;velocity added in the [x,y,z] cartesian directions&quot;</span><span class="p">,</span>

  <span class="n">MVN</span> <span class="mi">1</span>           <span class="s2">&quot;multiplies velocity in normal direction&quot;</span><span class="p">,</span>
  <span class="n">MVT</span> <span class="mi">1</span>           <span class="s2">&quot;multiplies velocity in tangential direction&quot;</span><span class="p">,</span>
  <span class="n">MVxyz</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>   <span class="s2">&quot;multiplies velocity in cartesian direction&quot;</span><span class="p">,</span>

  <span class="s2">&quot;comment&quot;</span><span class="p">:</span>      <span class="s2">&quot;orientation operators&quot;</span><span class="p">,</span>
  <span class="n">DUxyz</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>   <span class="s2">&quot;orientation added in the [x,y,z] cartesian directions&quot;</span><span class="p">,</span>
  <span class="n">MVN</span> <span class="mi">1</span>           <span class="s2">&quot;multiplies orientation in normal direction&quot;</span><span class="p">,</span>
  <span class="n">MVT</span> <span class="mi">1</span>           <span class="s2">&quot;multiplies orientation in tangential direction&quot;</span><span class="p">,</span>
  <span class="n">MVxyz</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>   <span class="s2">&quot;multiplies velocity in cartesian direction&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Commonly used boundary rules are:</p>
<ol class="arabic simple">
<li><p><strong>Position</strong></p></li>
</ol>
<blockquote>
<div><p><strong>Periodic boundary conditions</strong></p>
<p>Extended geometries, such as open systems or channel flows, often use periodic boundary conditions.
Periodic boundary conditions makes it possible to approximate an infinite system by wrapping coordinates around by their boundaries.
In order to achieve periodicity,
a planar boundary surface are created with <span class="math notranslate nohighlight">\(D_{x,\hat{n}}=L\)</span> as a shift equivalent to the system dimension.</p>
<figure class="align-center" id="id38">
<a class="reference internal image-reference" href="../_images/PBCschematic.png"><img alt="Logo" src="../_images/PBCschematic.png" style="width: 270.75px; height: 248.1px;" /></a>
<figcaption>
<p><span class="caption-text"><em>Example of a particle that passes through a through a periodic boundary.</em>
<em>The particle rewinds back to the point on the surface, and a shift is applied</em>
<em>in the surface normal direction that takes the particle to the left side.</em>
<em>There, the particle resumes streaming for time</em> <span class="math notranslate nohighlight">\(\delta t-t^*\)</span>.</span><a class="headerlink" href="#id38" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Periodic boundary conditions are implemented as the default boundary conditions (so no boundaries required in input scripts).
An example of the manual input for periodic boundary conditions on the left and right wall would be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="s2">&quot;comment&quot;</span><span class="p">:</span>      <span class="s2">&quot;Left PBC&quot;</span><span class="p">,</span>
<span class="s2">&quot;phantom&quot;</span><span class="p">:</span>      <span class="mi">0</span><span class="p">,</span>              <span class="s2">&quot;Ghost particles turned off (only required for solid boundaries)&quot;</span><span class="p">,</span>
<span class="s2">&quot;Q&quot;</span><span class="p">:</span>            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>      <span class="s2">&quot;Located on left-hand side of simulation domain &quot;</span><span class="p">,</span>
<span class="s2">&quot;aInv&quot;</span><span class="p">:</span>         <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>      <span class="s2">&quot;Normal vector faces right-ward&quot;</span><span class="p">,</span>
<span class="s2">&quot;P&quot;</span><span class="p">:</span>            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>   <span class="s2">&quot;Surface power = 1 (plane)&quot;</span><span class="p">,</span>
<span class="s2">&quot;R&quot;</span><span class="p">:</span>            <span class="mi">0</span><span class="p">,</span>              <span class="s2">&quot;Position - easiest to set to zero if using Q to define distance from origin&quot;</span><span class="p">,</span>
<span class="s2">&quot;DN&quot;</span><span class="p">:</span>           <span class="n">L</span><span class="p">,</span>              <span class="s2">&quot;Shift particle position by Lx in the direction of surface normal (shift right by Lx)&quot;</span><span class="p">,</span>
<span class="s2">&quot;DT&quot;</span><span class="p">:</span>           <span class="mi">0</span><span class="p">,</span>              <span class="s2">&quot;No shift in tangent direction&quot;</span>
<span class="p">},</span>
<span class="p">{</span>
<span class="s2">&quot;comment&quot;</span><span class="p">:</span>      <span class="s2">&quot;Right PBC&quot;</span><span class="p">,</span>
<span class="s2">&quot;phantom&quot;</span><span class="p">:</span>      <span class="mi">0</span><span class="p">,</span>              <span class="s2">&quot;Ghost particles turned off (only required for solid boundaries)&quot;</span><span class="p">,</span>
<span class="s2">&quot;Q&quot;</span><span class="p">:</span>            <span class="p">[</span><span class="n">Lx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>     <span class="s2">&quot;Located on right-hand side of simulation domain &quot;</span><span class="p">,</span>
<span class="s2">&quot;aInv&quot;</span><span class="p">:</span>         <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>     <span class="s2">&quot;Normal vector faces left-ward&quot;</span><span class="p">,</span>
<span class="s2">&quot;P&quot;</span><span class="p">:</span>            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>   <span class="s2">&quot;Surface power = 1 (plane)&quot;</span><span class="p">,</span>
<span class="s2">&quot;R&quot;</span><span class="p">:</span>            <span class="mi">0</span><span class="p">,</span>              <span class="s2">&quot;Position - easiest to set to zero if using Q to define distance from origin&quot;</span><span class="p">,</span>
<span class="s2">&quot;DN&quot;</span><span class="p">:</span>           <span class="n">L</span><span class="p">,</span>              <span class="s2">&quot;Shift particle position by Lx in the direction of surface normal (shift left by Lx)&quot;</span><span class="p">,</span>
<span class="s2">&quot;DT&quot;</span><span class="p">:</span>           <span class="mi">0</span><span class="p">,</span>              <span class="s2">&quot;No shift in tangent direction&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><strong>Velocity</strong></p></li>
</ol>
<blockquote>
<div><p><strong>Perfect-slip</strong></p>
<p>Perfect-slip rules are suitable for solid boundaries where viscous effects at the wall are negligible (shear stress at the boundary is zero).
Achieving perfect-slip utilises <em>reflective</em> boundary rules to the velocity.
The normal component of the velocity is reversed <span class="math notranslate nohighlight">\(M_{v,\hat{n}} = -1\)</span>,
while the tangential component is unchanged <span class="math notranslate nohighlight">\(M_{v,\hat{t}} = 1\)</span>.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/perfectslip.png"><img alt="Logo" src="../_images/perfectslip.png" style="width: 330.8px; height: 160.4px;" /></a>
</figure>
<p>In the input files, perfect slip can be enabled by</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;comment&quot;</span><span class="p">:</span><span class="w">          </span><span class="s2">&quot;Perfect slip BC&quot;</span><span class="p">,</span>
<span class="nt">&quot;MVN&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">-1</span><span class="p">,</span>
<span class="nt">&quot;MVT&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
<p><strong>No-slip</strong></p>
<p>No-slip refers to any impermeable boundary condition that brings the velocity of the fluid to zero at the wall.
Achieving no-slip utilises <em>bounce-back</em> boundary rules to the velocity <a class="reference internal" href="../References/References.html#allahyarov2002" id="id31"><span>[Allahyarov2002]</span></a>,
reversing the normal and tangential component of the velocity so that <span class="math notranslate nohighlight">\(M_{v,\hat{n}} = M_{v,\hat{t}} = -1\)</span>.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/noslip.png"><img alt="Logo" src="../_images/noslip.png" style="width: 330.8px; height: 160.4px;" /></a>
</figure>
<p>In the input files, no-slip can be enabled by</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;comment&quot;</span><span class="p">:</span><span class="w">          </span><span class="s2">&quot;No-slip BC&quot;</span><span class="p">,</span>
<span class="nt">&quot;MVN&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">-1</span><span class="p">,</span>
<span class="nt">&quot;MVT&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">-1</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When no-slip boundary conditions are requred, <a class="reference internal" href="#ghosts"><span class="std std-ref">ghosts particles</span></a> must be included.</p>
</div>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p><strong>Orientation</strong></p></li>
</ol>
<p>For liquid crystalline fluids, boundary conditions (or anchoring conditions)
can be applied so that the particle orientation <span class="math notranslate nohighlight">\(\hat{u}_i\)</span> aligns in the normal direction to the boundary (homeotropic)
or tangential with the boundary (planar).</p>
<blockquote>
<div><p><strong>Unanchored/free</strong></p>
<p>If collisions with the boundary surface do not modify the orientation then the nematic is unanchored to the colloid. This requires <span class="math notranslate nohighlight">\(M_{v,\hat{n}} = 1\)</span> and <span class="math notranslate nohighlight">\(M_{v,\hat{t}} = 1\)</span>.</p>
<p>In the input files, planar anchoring can be enabled by</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;comment&quot;</span><span class="p">:</span><span class="w">           </span><span class="s2">&quot;Unanchored&quot;</span><span class="p">,</span>
<span class="nt">&quot;MUN&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">1</span><span class="p">,</span>
<span class="nt">&quot;MUT&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
<p><strong>Homeotropic</strong></p>
<p>Alignment normal to the boundary requires <span class="math notranslate nohighlight">\(M_{v,\hat{n}} = 1\)</span> and <span class="math notranslate nohighlight">\(M_{v,\hat{t}} = 0\)</span>.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/homeotropic.png"><img alt="Logo" src="../_images/homeotropic.png" style="width: 292.40000000000003px; height: 74.2px;" /></a>
</figure>
<p>In the input files, homeotropic anchoring can be enabled by</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;comment&quot;</span><span class="p">:</span><span class="w">          </span><span class="s2">&quot;Homeotropic anchoring&quot;</span><span class="p">,</span>
<span class="nt">&quot;MUN&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">1</span><span class="p">,</span>
<span class="nt">&quot;MUT&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">0</span><span class="p">,</span>
</pre></div>
</div>
<p><strong>Planar</strong></p>
<p>Alignment tangential to the boundary requires <span class="math notranslate nohighlight">\(M_{v,\hat{n}} = 0\)</span> and <span class="math notranslate nohighlight">\(M_{v,\hat{t}} = 1\)</span>.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/planar.png"><img alt="Logo" src="../_images/planar.png" style="width: 293.2px; height: 74.2px;" /></a>
</figure>
<p>In the input files, planar anchoring can be enabled by</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;comment&quot;</span><span class="p">:</span><span class="w">           </span><span class="s2">&quot;Planar anchoring&quot;</span><span class="p">,</span>
<span class="nt">&quot;MUN&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">0</span><span class="p">,</span>
<span class="nt">&quot;MUT&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Homeotropic and planar anchoring have overrides. By setting <code class="docutils literal notranslate"><span class="pre">&quot;homeotropic&quot;</span></code> to <code class="docutils literal notranslate"><span class="pre">1</span></code> <strong>inside</strong> <code class="docutils literal notranslate"><span class="pre">&quot;bc&quot;</span></code> array, homeotropic anchoring overwrites <code class="docutils literal notranslate"><span class="pre">&quot;MUN&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;MUT&quot;</span></code>:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;homeotropic&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
<p>Likewise, by setting <code class="docutils literal notranslate"><span class="pre">&quot;planar&quot;</span></code> to <code class="docutils literal notranslate"><span class="pre">1</span></code> <strong>inside</strong> <code class="docutils literal notranslate"><span class="pre">&quot;bc&quot;</span></code> array, planar anchoring overwrites <code class="docutils literal notranslate"><span class="pre">&quot;MUN&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;MUT&quot;</span></code>:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;planar&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
</div>
</div></blockquote>
</section>
<section id="domain-walls-override">
<span id="domainwallsoverride"></span><h4>Domain walls override<a class="headerlink" href="#domain-walls-override" title="Permalink to this heading">#</a></h4>
<p>While NAIMH-MPCD is constructed to deep the definition of the <a class="reference internal" href="#systemdomain"><span class="std std-ref">system’s domain</span></a> separate from the boundaries, it is frequently the case that boundaries coincide with the domain. Therefore, for convenience, NAIMH-MPCD has an override to put periodic boundary conditions (<code class="docutils literal notranslate"><span class="pre">&quot;domainWalls&quot;:</span> <span class="pre">1)</span> <span class="pre">or</span> <span class="pre">no-slip</span> <span class="pre">boundary</span> <span class="pre">conditions</span>&#160; <span class="pre">(</span></code>“domainWalls”: 0) on every domain wall. This is done in the <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<p>This override will add extra BCs to the simulation, on top of the declared ones, on the domain walls. If set to 1, it places PBCs, and if set to 0 it places solid walls.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;domainWalls&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
<p>Additional boundary conditions can be specified after the override.</p>
</section>
<section id="phantom-particles">
<span id="ghosts"></span><h4>Phantom particles<a class="headerlink" href="#phantom-particles" title="Permalink to this heading">#</a></h4>
<p>When applying no-slip boundary conditions, bounce-back conditions are not sufficient. This is because fluid cells being intersected by the boundary reduce the that cell’s population below the average number density.
This can be because the random grid shifts (for Galilean invariance) stops cell edges from coiniciding with the boundary surface or because curved/slanted surfaces do coincide with cell edges.
As a consequence of this, the apparent viscosity in cells near walls is less than expected (since <a class="reference internal" href="../ExtraTheory/ExtraTheory.html#viscositysection"><span class="std std-ref">viscosity depends on the particle number density</span></a>). A standard method to correct no-slip, so that <span class="math notranslate nohighlight">\(\vec{v}^{\mathrm{cm}}_c \approx 0\)</span> <a class="reference internal" href="../References/References.html#lamura2001" id="id32"><span>[Lamura2001]</span></a>, is to fill the cell with <span class="math notranslate nohighlight">\(N_\mathrm{ghost} =\langle N_c \rangle - N_c\)</span> phantom (or virtual) particles so that the effective cell density <span class="math notranslate nohighlight">\(N_c\)</span> is equal to the average density <span class="math notranslate nohighlight">\(\langle N_c \rangle\)</span>.</p>
<div class="math-wrapper docutils container" id="eq-virtualparticles1">
<span id="equation-eq-virtualparticles1"></span><div class="math notranslate nohighlight" id="eq-virtualparticles1">
<span id="equation-eq-virtualparticles1"></span><span class="eqno">(27)<a class="headerlink" href="#eq-virtualparticles1" title="Permalink to this equation">#</a></span>\[\vec{v}^{\mathrm{cm}}_c = \frac{1}{N_c}\left(\sum_{i=1}^{N_c} \vec{v_i} + \sum_{j=1}^{N_{\mathrm{ghost}}} \vec{v_j}^{\mathrm{ghost}} \right)\]</div>
</div>
<p>Each of these virtual particles <span class="math notranslate nohighlight">\(\vec{v_j}^{\mathrm{ghost}}\)</span> have a velocity drawn from a Maxwell Boltzmann distribution about zero with the same temperature of the fluid, <span class="math notranslate nohighlight">\(k_B T\)</span>.
Instead of determining each phantom particle’s velocity individually,
a simpler method is instead to select the entire correction <span class="math notranslate nohighlight">\(\vec{v}^{\mathrm{ghost}}\)</span>
from a Maxwell Boltzmann distribution about zero but with a variance of <span class="math notranslate nohighlight">\(N_{\mathrm{ghost}} k_B T\)</span> <a class="reference internal" href="../References/References.html#lamura2002" id="id33"><span>[Lamura2002]</span></a>.</p>
<div class="math-wrapper docutils container" id="eq-virtualparticles2">
<span id="equation-eq-virtualparticles2"></span><div class="math notranslate nohighlight" id="eq-virtualparticles2">
<span id="equation-eq-virtualparticles2"></span><span class="eqno">(28)<a class="headerlink" href="#eq-virtualparticles2" title="Permalink to this equation">#</a></span>\[\vec{v}^{\mathrm{cm}}_c = \frac{1}{N_c}\left(\sum_{i=1}^{N_c} \vec{v_i} + \vec{v}^{\mathrm{ghost}} \right)\]</div>
</div>
<p>Phantom particles are turned on for each boundary through the <code class="docutils literal notranslate"><span class="pre">&quot;phantom&quot;</span></code> tag <strong>inside</strong> <code class="docutils literal notranslate"><span class="pre">&quot;bc&quot;</span></code> array. Setting the tag to <code class="docutils literal notranslate"><span class="pre">0</span></code> turns off phantom particles, while <code class="docutils literal notranslate"><span class="pre">1</span></code> turns it on:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;BC&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="p">[</span>
<span class="w">        </span><span class="nt">&quot;phantom&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">1</span><span class="p">,</span><span class="w">          </span><span class="s2">&quot;this is 0 for off and 1 for on&quot;</span>
<span class="w">    </span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Ghost particles should be turned on for any solid boundary with no-slip.
Without it, the reduced particle density in cells leads to a lower viscosity in the proximity of walls.</p>
</div>
</section>
<section id="strong-anchoring">
<h4>Strong anchoring<a class="headerlink" href="#strong-anchoring" title="Permalink to this heading">#</a></h4>
<p>Since orientation boundary conditions are only applied to the subset of particles <span class="math notranslate nohighlight">\(N_{c*} \leq N_c\)</span> that violate the surface boundary equation <span class="math notranslate nohighlight">\(S(\vec{x})\leq0\)</span>, the cell director <span class="math notranslate nohighlight">\(\hat{n}_c\)</span> mixes between the anchored and un-anchored orientations.
The effective anchoring strength is therefore heavily dependent on the proportion <span class="math notranslate nohighlight">\(N_{c*} / N_c\)</span>, with strongest anchoring acheived when <span class="math notranslate nohighlight">\(N_{c*} = N_c\)</span>.
To strengthen the effective anchoring, we apply the orientation boundary condition to all <span class="math notranslate nohighlight">\(N_c\)</span> particles <a class="reference internal" href="../References/References.html#head2024" id="id34"><span>[Head2024]</span></a>.</p>
<p>Strong anchoring is applied by default for solid boundaries, but requires the <code class="docutils literal notranslate"><span class="pre">phantom</span></code> tag to be turned on:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;BC&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="p">[</span>
<span class="w">        </span><span class="nt">&quot;phantom&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">1</span><span class="p">,</span><span class="w">          </span><span class="s2">&quot;this is 0 for off and 1 for on&quot;</span>
<span class="w">    </span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="inside-or-outside-boundaries">
<span id="inout"></span><h3>Inside or outside boundaries<a class="headerlink" href="#inside-or-outside-boundaries" title="Permalink to this heading">#</a></h3>
<p>In NIAMH-MPCD, the MPCD fluid can be outside or inside a boundary condition. This is because the surface coefficient <span class="math notranslate nohighlight">\(\vec{A}=(A_x,A_y,A_z)\)</span> need not be positive; therefore, the surface normal can point either “inside” or “outside”.</p>
<blockquote>
<div><div class="table-wrapper colwidths-given docutils container">
<table class="docutils align-center">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><a class="reference internal image-reference" href="../_images/BC_classic.jpg"><img alt="../_images/BC_classic.jpg" class="align-center" src="../_images/BC_classic.jpg" style="width: 95%;" /></a>
</td>
<td><a class="reference internal image-reference" href="../_images/BC_another_bc_inside.jpg"><img alt="../_images/BC_another_bc_inside.jpg" class="align-center" src="../_images/BC_another_bc_inside.jpg" style="width: 95%;" /></a>
</td>
</tr>
</tbody>
</table>
</div>
</div></blockquote>
<p>While this can be done by hand, NIAMH-MPCD includes a flag for flipping surfaces inside out.
When the flag is on <span class="math notranslate nohighlight">\(\vec{A}\to-\vec{A}\)</span>.
This is done through the <code class="docutils literal notranslate"><span class="pre">&quot;inv&quot;</span></code> parameter tag <strong>inside</strong> <code class="docutils literal notranslate"><span class="pre">&quot;bc&quot;</span></code> array.
It is off when zero and on when unity:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;BC&quot;</span><span class="p">:</span>
<span class="w">  </span><span class="p">[</span>
<span class="w">      </span><span class="nt">&quot;inv&quot;</span><span class="p">:</span><span class="w">      </span><span class="mi">1</span><span class="p">,</span>

<span class="w">  </span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0.</p>
</div>
</section>
<section id="thermal-boundary-conditions">
<span id="thermalbcs"></span><h3>Thermal boundary conditions<a class="headerlink" href="#thermal-boundary-conditions" title="Permalink to this heading">#</a></h3>
<p>The rules described <a class="reference internal" href="#subsection-boundaryrules"><span class="std std-ref">described so far</span></a> have assumed that the velocity changes deterministicly according to a set of rules. There are two other assumptions about the collision with the boundary that can be made:</p>
<blockquote>
<div><ul class="simple">
<li><p>Respects all conservation laws by impact analysis: <code class="docutils literal notranslate"><span class="pre">&quot;colType&quot;:</span> <span class="pre">0</span></code></p></li>
<li><p>Rule based collisions at the surface. <code class="docutils literal notranslate"><span class="pre">&quot;colType&quot;:</span> <span class="pre">1</span></code></p></li>
<li><p>Probabilistic reflections at the surface. <code class="docutils literal notranslate"><span class="pre">&quot;colType&quot;:</span> <span class="pre">2</span></code></p></li>
</ul>
</div></blockquote>
<p>These options can be selected <strong>inside</strong> <code class="docutils literal notranslate"><span class="pre">&quot;bc&quot;</span></code> array:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">&quot;BC&quot;:</span>
<span class="go">[</span>
<span class="go">    {</span>
<span class="go">        &quot;colType&quot;: 1</span>
<span class="go">    }</span>
<span class="go">]</span>
</pre></div>
</div>
<p>If the probabilistic reflections is selected (<code class="docutils literal notranslate"><span class="pre">&quot;colType&quot;:</span> <span class="pre">2</span></code>) then the temperature of the surface must be set (it can differ from the fluid’s thermostat).
In this case, particles will draw random velocities from thermal distributions, with the tangential value of the velocity of the particle drawn from a Maxwell-Boltzmann distribution and the normal value drawn from a Rayleigh distribution.</p>
<p>The temperature is set <strong>inside</strong> <code class="docutils literal notranslate"><span class="pre">&quot;bc&quot;</span></code> array:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">&quot;BC&quot;:</span>
<span class="go">[</span>
<span class="go">    {</span>
<span class="go">        &quot;kbt&quot;: 0.1</span>
<span class="go">    }</span>
<span class="go">]</span>
</pre></div>
</div>
</section>
</section>
<section id="extra-options">
<span id="extraschapter"></span><h2><a class="toc-backref" href="#id46" role="doc-backlink">Extra options</a><a class="headerlink" href="#extra-options" title="Permalink to this heading">#</a></h2>
<section id="thermostats">
<span id="id35"></span><h3>Thermostats<a class="headerlink" href="#thermostats" title="Permalink to this heading">#</a></h3>
<p>In driving flows, work is done. Because the MPCD fluid is viscous, the work done on the fluid is continually converted into heat by internal friction, as represented by the MPCD collision operator.</p>
<p>In real systems, such heating occurs but is often mediated and removed by container walls acting as reservoirs. Thermostats are algorithms that act as virtual reservoirs for the simulation. They keep the system near the desired fixed temperature even when work is being done on the fluid. Thermal-wall boundary conditions are discussed in <a class="reference internal" href="#thermalbcs"><span class="std std-ref">thermal boundary conditions</span></a>. Some MPCD collision operators conserve energy (such as <a class="reference internal" href="#srd"><span class="std std-ref">SRD</span></a>), while others conserve thermal energy (such as <a class="reference internal" href="#andersen"><span class="std std-ref">Andersen-thermostatted MPCD</span></a>).</p>
<p>The MPCD fluid will have an instantaneous thermal energy, calculated via the equipartition function to be <span class="math notranslate nohighlight">\(k_\text{B}T(t) = \sum_i \left(\vec{v}_i-\left\langle\vec{v}\right\rangle\right)^2 / (d N_\text{tot})\)</span>, where <span class="math notranslate nohighlight">\(\left\langle\vec{v}\right\rangle\)</span> is the system averaged velocity, <span class="math notranslate nohighlight">\(d\)</span> is the dimensionality and <span class="math notranslate nohighlight">\(N_\text{tot}\)</span> is the total number of MPCD particles. The thermostat has a set thermal energy <span class="math notranslate nohighlight">\(k_\text{B}T_0\)</span>.</p>
<p>For operations that conserve energy (i.e. <a class="reference internal" href="#srd"><span class="std std-ref">SRD collision operators</span></a>), a user may wish to apply a global or local thermostat. <code class="docutils literal notranslate"><span class="pre">&quot;tsTech&quot;</span></code> specifies which thermostat is applied:</p>
<ul>
<li><p>None</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;tsTech&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">0</span><span class="p">,</span>
</pre></div>
</div>
</li>
<li><p>Velocity scaling is used as the thermostat.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;tsTech&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
<p>The simplest method to thermostat a system is to rescale the velocities. Since the intantaneous kinetic energy of the constituents constitutes the thermal energy, a desired temperature is achieved by scaling every velocity by <span class="math notranslate nohighlight">\(\sqrt{T_0/T}\)</span>. Rescaling the velocity in this way instantaneously moves the temperature to its fixed value of <span class="math notranslate nohighlight">\(T_0\)</span>.</p>
</li>
<li><p>The Berendsen thermostat is used.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;tsTech&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">2</span><span class="p">,</span>
</pre></div>
</div>
<p>The Berendsen thermostat rescales the velocities but does so with a temporal relaxation toward the thermostat value over a finite period of time. The Berendsen thermostat defines a relaxation time, <span class="math notranslate nohighlight">\(\tau_\text{R}\)</span>, that moves <span class="math notranslate nohighlight">\(T/T_0 \to 1\)</span> by rescaling the velocities by <span class="math notranslate nohighlight">\(\left[ 1+\left(T/T_0-1\right)\left(\delta t / \tau_\text{R}\right) \right]^{1/2}\)</span>.</p>
<p>The relaxation time is set by:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;tau&quot;</span><span class="p">:</span><span class="w">         </span><span class="mf">0.5</span><span class="p">,</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0.5.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Both the velocity rescaling and the Berendsen thermostats share some weaknesses:</p>
<ul class="simple">
<li><p>If the temperature increases in one region of the fluid then both of these global, velocity e-scaling thermostats will cool distant regions.</p></li>
<li><p>Even if work is being done to drive macroscopic flow in a particular direction, these thermostats will scale velocity in all directions, repressing thermal motion in the perpendicular directions in an attempt to lower the total kinetic energy. In extreme cases, fluctuations are repressed.</p></li>
</ul>
</div>
</li>
<li><p>The Heyes thermostat is used.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;tsTech&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">3</span><span class="p">,</span>
</pre></div>
</div>
<p>The Heyes algorithm is a stochastic thermostat that is applied <strong>locally</strong> to each MPCD cell. In a sense (like acceleration or velocity rescaling) it becomes a part of the collision operation. The Heyes thermostat enacts the following procedure:</p>
<ul class="simple">
<li><p>A random number is homogeneously generated in the range <span class="math notranslate nohighlight">\(r_1 \in \left[1,1+c\right]\)</span>, where <span class="math notranslate nohighlight">\(c\)</span> is the control parameter of the thermostat and should be between 0.05 and 0.3.</p></li>
<li><p>Generate a second random number <span class="math notranslate nohighlight">\(r_2 \in \left[0,1\right]\)</span>.</p>
<ul>
<li><p>If the second random number is <span class="math notranslate nohighlight">\(r_2 &gt; 0.5\)</span> then the scaling factor is the first random number, <span class="math notranslate nohighlight">\(\gamma = r_1\)</span>.</p></li>
<li><p>Else the scaling factor is the inverse of the first random number, <span class="math notranslate nohighlight">\(\gamma=r_1^{-1}\)</span></p></li>
</ul>
</li>
<li><p>Generate a third (and final) random number <span class="math notranslate nohighlight">\(r_3 \in \left[0,1\right]\)</span> and let</p></li>
</ul>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[A = \gamma^{\dim\left(N_c-1\right)} \exp{\left[-\left(\frac{\gamma^2-1}{2 k_\text{B} T_0}\right) \sum_i^{N_c} m_i \left( \vec{v}_i-\vec{v}c \right)^2 \right]}.\]</div>
</div>
<p>If <span class="math notranslate nohighlight">\(r_3 \geq \text{min}\left[1,A\right]\)</span> then set $gamma=1$ (i.e. do not rescale the velocities in the current cell).</p>
<ul class="simple">
<li><p>Rescale the velocities in the current cell.</p></li>
</ul>
</li>
<li><p>The final option is not a thermostat. It sets the maximum velocity (by hijacking the <code class="docutils literal notranslate"><span class="pre">grav</span></code>) and truncates any components that are larger than the specified maximum.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;tsTech&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">4</span><span class="p">,</span>
<span class="nt">&quot;grav&quot;</span><span class="p">:</span><span class="w">           </span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a thermostat is needed, users are encouraged to use <a class="reference internal" href="#andersen"><span class="std std-ref">Andersen-thermostatted MPCD</span></a> (<a class="reference internal" href="#langevin"><span class="std std-ref">Langevin-thermostatted MPCD</span></a> is also an option).</p>
</div>
</section>
<section id="zeroing-the-net-momentum">
<span id="zeromom"></span><h3>Zeroing the net momentum<a class="headerlink" href="#zeroing-the-net-momentum" title="Permalink to this heading">#</a></h3>
<p>Many of the initialization routines assign <a class="reference internal" href="#velocity"><span class="std std-ref">stochastic values to the particle velocities</span></a>. To identically zero the system’s net momentum after initialization, turn it on in your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file by setting:</p>
<blockquote>
<div><div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;rFrame&quot;</span><span class="p">:</span><span class="w">         </span><span class="mi">1</span><span class="p">,</span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0 (off).</p>
</div>
<p>Similarly, the system-wide net momentum can be zeroed any number of time steps. This will destroy any net flow but may be desirable in some situations. Set the zeroing time in your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file by:</p>
<blockquote>
<div><div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;zeroNetMom&quot;</span><span class="p">:</span><span class="w">        </span><span class="mi">5000</span><span class="p">,</span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value is 0 (off). Setting 1 will zero the net momentum every timestep, while 42 will zero the net momentum every 42 timesteps.</p>
</div>
</section>
<section id="turn-off-hydrodynamics">
<span id="nohi"></span><h3>Turn-off hydrodynamics<a class="headerlink" href="#turn-off-hydrodynamics" title="Permalink to this heading">#</a></h3>
<p>Hydrodynamics can be turned off, which essentially creates a Langenvin dynamics simulation with a computationally costly Brownian thermostat.
Though computationally costly, the benefit is that the material properties of the fluid are preserved.
By turning them off, the role of hydrodynamic interactions can be probed.</p>
<p>Hydrodynamic interactions are turned off by randomly exchanging the velocity of all fluid particles after  the collision collision step <a class="reference internal" href="../References/References.html#ali2004" id="id36"><span>[Ali2004]</span></a>.</p>
<p>To turn off hydrodynamic interactions, add the following to your input <code class="docutils literal notranslate"><span class="pre">.json</span></code> file:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">&quot;noHI&quot;:         1,</span>
</pre></div>
</div>
<figure class="align-center" id="id39">
<a class="reference internal image-reference" href="../_images/brownian.png"><img alt="Logo" src="../_images/brownian.png" style="width: 369.3px; height: 354.59999999999997px;" /></a>
<figcaption>
<p><span class="caption-text">Hydrodynamic interactions are “scrambled” by randomly exchange particle velocities.</span><a class="headerlink" href="#id39" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>If on the other hand a friction acts on the fluid (like a Brinkman term) (rather than ignoring hydrodynamic interactions), this can be set as a <a class="reference internal" href="#damping"><span class="std std-ref">damping friction coefficient</span></a>.</p>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../HardCoded/HardCoded.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Hard-coded options</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="../Tutorials/Tutorials.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Tutorials</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, Shendruk Lab
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">MPCD usage</a><ul>
<li><a class="reference internal" href="#system-properties">System properties</a><ul>
<li><a class="reference internal" href="#domain">Domain</a></li>
<li><a class="reference internal" href="#thermal-energy">Thermal energy</a></li>
<li><a class="reference internal" href="#timestep">Timestep</a></li>
<li><a class="reference internal" href="#simulation-steps">Simulation steps</a></li>
<li><a class="reference internal" href="#warmup-steps">Warmup steps</a></li>
<li><a class="reference internal" href="#random-number-seed">Random number seed</a></li>
<li><a class="reference internal" href="#nematic-fluid">Nematic fluid</a></li>
<li><a class="reference internal" href="#multiphase">Multiphase</a></li>
<li><a class="reference internal" href="#galilean-invariance">Galilean invariance</a></li>
<li><a class="reference internal" href="#terminal-output">Terminal output</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mpcd-particle-properties">MPCD particle properties</a><ul>
<li><a class="reference internal" href="#isotropic-fluid">Isotropic fluid</a><ul>
<li><a class="reference internal" href="#position-initialization">Position initialization</a></li>
<li><a class="reference internal" href="#velocity-initialization">Velocity initialization</a></li>
<li><a class="reference internal" href="#mass">Mass</a></li>
<li><a class="reference internal" href="#population">Population</a></li>
<li><a class="reference internal" href="#number-density">Number density</a></li>
<li><a class="reference internal" href="#orientation-initialization">Orientation initialization</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#mpcd-cell-properties">MPCD cell properties</a><ul>
<li><a class="reference internal" href="#cell-size">Cell size</a></li>
<li><a class="reference internal" href="#numberincell">Number density</a></li>
<li><a class="reference internal" href="#center-of-mass-velocity">Center of mass velocity</a></li>
<li><a class="reference internal" href="#center-of-mass">Center of mass</a></li>
<li><a class="reference internal" href="#moment-of-inertia">Moment of inertia</a></li>
<li><a class="reference internal" href="#nematic-order">Nematic order</a></li>
<li><a class="reference internal" href="#local-velocity-gradient-tensor">Local velocity gradient tensor</a></li>
</ul>
</li>
<li><a class="reference internal" href="#collision-operators">Collision operators</a><ul>
<li><a class="reference internal" href="#stochastic-rotation-dynamics">Stochastic rotation dynamics</a><ul>
<li><a class="reference internal" href="#random-cartesian-axis-srd">Random-Cartesian-axis SRD</a></li>
<li><a class="reference internal" href="#thermostatting-srd">Thermostatting SRD</a></li>
</ul>
</li>
<li><a class="reference internal" href="#andersen-mpcd">Andersen MPCD</a><ul>
<li><a class="reference internal" href="#conserving-angular-momentum">Conserving angular momentum</a></li>
</ul>
</li>
<li><a class="reference internal" href="#langevin-mpcd">Langevin MPCD</a></li>
<li><a class="reference internal" href="#nematic-mpcd">Nematic MPCD</a><ul>
<li><a class="reference internal" href="#nematogen-collision-operator">Nematogen collision operator</a><ul>
<li><a class="reference internal" href="#mean-field-potential">Mean field potential</a></li>
<li><a class="reference internal" href="#isotropic-nematic-transition">Isotropic-nematic transition</a></li>
<li><a class="reference internal" href="#frank-elastic-coefficients">Frank elastic coefficients</a></li>
</ul>
</li>
<li><a class="reference internal" href="#two-way-couping-between-flow-and-orientation">Two-way couping between flow and orientation</a><ul>
<li><a class="reference internal" href="#rotational-friction-coefficient">Rotational friction coefficient</a></li>
<li><a class="reference internal" href="#shear-susceptibility">Shear susceptibility</a></li>
<li><a class="reference internal" href="#tumbling-parameter">Tumbling parameter</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#active-nematic-mpcd">Active-nematic MPCD</a><ul>
<li><a class="reference internal" href="#variation-on-the-strength-of-activity">Variation on the strength of activity</a><ul>
<li><a class="reference internal" href="#particle-carried-activity">Particle-carried activity</a></li>
<li><a class="reference internal" href="#cell-carried-activity">Cell-carried activity</a></li>
<li><a class="reference internal" href="#modulated-activity">Modulated activity</a></li>
<li><a class="reference internal" href="#ratio-of-active-particles">Ratio of active particles</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#active-polar-mpcd">Active-Polar MPCD</a><ul>
<li><a class="reference internal" href="#vicsek-mpcd">Vicsek MPCD</a></li>
<li><a class="reference internal" href="#anderson-active-polar-mpcd">Anderson-active polar MPCD</a></li>
<li><a class="reference internal" href="#langevin-active-polar-mpcd">Langevin-active polar MPCD</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multiphase-mpcd">Multiphase MPCD</a><ul>
<li><a class="reference internal" href="#phase-separation">Phase separation</a></li>
<li><a class="reference internal" href="#interaction-matrix">Interaction matrix</a></li>
</ul>
</li>
<li><a class="reference internal" href="#external-fields">External fields</a><ul>
<li><a class="reference internal" href="#gravitational-acceleration">Gravitational acceleration</a></li>
<li><a class="reference internal" href="#magnetic-field">Magnetic field</a><ul>
<li><a class="reference internal" href="#magnetic-susceptibility">Magnetic susceptibility</a></li>
</ul>
</li>
<li><a class="reference internal" href="#friction-coefficient">Friction coefficient</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#boundary-conditions">Boundary conditions</a><ul>
<li><a class="reference internal" href="#surfaces">Surfaces</a><ul>
<li><a class="reference internal" href="#standard-surfaces">Standard surfaces</a></li>
<li><a class="reference internal" href="#additional-surface-forms">Additional surface forms</a><ul>
<li><a class="reference internal" href="#slanted-surfaces">Slanted surfaces</a></li>
<li><a class="reference internal" href="#absolute-value">Absolute value</a></li>
<li><a class="reference internal" href="#non-four-fold-symmetric-surfaces">Non-four-fold symmetric surfaces</a></li>
<li><a class="reference internal" href="#wavy-surfaces">Wavy surfaces</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#boundary-rules">Boundary rules</a><ul>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
<li><a class="reference internal" href="#boundary-operators">Boundary operators</a></li>
<li><a class="reference internal" href="#domain-walls-override">Domain walls override</a></li>
<li><a class="reference internal" href="#phantom-particles">Phantom particles</a></li>
<li><a class="reference internal" href="#strong-anchoring">Strong anchoring</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inside-or-outside-boundaries">Inside or outside boundaries</a></li>
<li><a class="reference internal" href="#thermal-boundary-conditions">Thermal boundary conditions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extra-options">Extra options</a><ul>
<li><a class="reference internal" href="#thermostats">Thermostats</a></li>
<li><a class="reference internal" href="#zeroing-the-net-momentum">Zeroing the net momentum</a></li>
<li><a class="reference internal" href="#turn-off-hydrodynamics">Turn-off hydrodynamics</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>